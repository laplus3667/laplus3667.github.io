[{"categories":["物件導向編程"],"content":"沈思輸入-處理-輸出模型  紫式晦澀每日一篇文章第20天\n 前言   今天是2022年第18天, 全年第3週, 一月的第三個週二. 今天來思考「IPO:Input-Process-Output」模型. 這種模型可看作認知模型, 也可看作計算模型, 隨處可見. 把算法思維帶入各種場景, 我們便能可視化流程工程, 優化系統.\n  今天的素材主要來自各種提到「IPO:Input-Process-Output」模型的文章. 相關的材料非常多, 也算是可以把所見所聞做個整理.\n  輸入-處理-輸出模型本體論 輸入-過程-輸出（IPO）模型:   輸入-處理-輸出（IPO）模型，或輸入-處理-輸出模式，是系統分析(systems analysis)和軟體工程(software engineering)中廣泛使用的方法 用於描述資訊處理程式或其他過程的結構。 The structure of an information processing program or other process. 許多介紹性寫程式和系統分析文字將此作為描述過程的最基本結構。 The most basic structure for describing a process.  系統(輸入-處理-輸出)\u0026ndash;環境\u0026ndash;反饋  5系統, 環境, 反饋: 建立輸入-過程-輸出（IPO）模型實際上是要建立「系統」. 有了系統以後, 就能夠與「環境」互動. 互動以後, 得到「反饋」來調整「系統狀態」.\n  視為過程的電腦程式:\n   電腦程式(Computer Program)對於另一種使用輸入-過程輸出模型的過程非常有用，接收來自使用者或其他來源的輸入，對輸入進行一些計算，並返回計算結果。 從本質上講，該「系統」與「環境」分離，從而將「輸入」和「輸出」定義為一個統一的機制。  系統將工作分為輸入, 處理, 輸出三個部分:   輸入: 從「環境(Environment)」的要求. A requirement from the environment (input) 處理: 基於要求的「計算(Computation). A computation based on the requirement (process) 輸出: 提供「環境」結果. A provision for the environment (output)  系統思維: 可靠的推論:   系統思維是透過對基本結構的理解日益深入地理解，對行為進行可靠推斷的藝術和科學 Systems thinking is the art and science of making reliable inferences about behaviour by developing an increasingly deep understanding of the understanding of the underlying structure  作為思維模型的IPO IPO實例:   工業: 原材料\u0026ndash;\u0026gt;工廠加工\u0026ndash;\u0026gt;工業產品 考核: 員工工作內容\u0026ndash;\u0026gt;考核規則\u0026ndash;\u0026gt;員工考核結果 認知: 對環境的觀察, 欣賞, 交流, 閱讀\u0026ndash;\u0026gt;大腦進行類比, 歸納, 演繹等抽象思考\u0026ndash;\u0026gt; 解釋現象的思維模型. 數據分析: 大量數據\u0026ndash;\u0026gt;統計分析處理\u0026ndash;\u0026gt;有用信息, 結論. 計算機: 輸入指令\u0026ndash;\u0026gt;運算處理\u0026ndash;\u0026gt;輸出計算結果 造筆記: 心法\u0026ndash;\u0026gt;技法\u0026ndash;\u0026gt;用法  輸入要正確, 處理要合理, 輸出有價值 輸入要正確:   持續學習，擴大自己知識的深度和廣度，從而不斷提升自己有效過濾錯誤輸入信息能力。 管理者要有能力甄別下屬所反饋信息正確性，帶主觀情緒的負面信息只會讓管理者做出錯誤的決策 在交流學習中不能聽啥是啥，要有個人客觀辯證的能力，否則會很容易學到錯誤的知識。  處理要合理:   要努力學習掌握更多已經被證明是有效的思維模型 這樣我們在解決問題或做決策的時候才有更合適的選擇，而不是拿著錘子看什麼都是釘子。  輸出有價值:   要掌握各種標準化的模板, 穩定有效的輸出, 去看見更深一層的資訊價值.  人生的IPO模型 人生的IPO:   人生: 信息輸入\u0026ndash;\u0026gt;大腦處理\u0026ndash;\u0026gt;總結輸出  信息輸入\u0026ndash;大腦處理\u0026ndash;總結輸出 信息輸入:兩種途徑   一手信息: 與人聊天, 親手動手實踐 二手信息: 從他人總結出的經驗, 看書, 看部落格文章   看書是得到二手信息; 家教是得到一手信息\n 大腦處理:不斷收集各種模型   理解世界, 要找到自己底層的思維模型(Mental Models) 思維模型來自不同學科不同方面, 80~90個模型能處理90%以上的問題.  總結輸出:持續的大量的輸出   總結和分享為目標, 進行整理產出. 寫文章, 文件, 根據聽眾觀眾的需求, 練習精進各種體裁的寫作.  結果驅動的IPO模型 定義IPO: 系統思考, 系統設計的底層原理. 由輸入, 加工, 輸出三部分組成的閉環.   I \u0026ndash; Inputs (輸入): 數據, 人力, 物質等等 P \u0026ndash; Processes (工序): 對輸入加工處理的方法流程 O \u0026ndash; Outputs (輸出): 工序的輸出.  閉環思維:   我們先收集信息，再根據收集到的信息（輸入），決定下一步的決策和行動（工序），若結果是我們期望的（輸出），就重復這一過程，構成了一個單環迴路。 單環思維是人類的本能思維，我們餓了，點了一個外賣，味道不錯，下一次還繼續點這個外賣。我們越來越熟練，也越來越依賴這個閉環，迴路就越難打破。 這個循環迴路會逐漸固化為一種心智模式——決定我們的思考方式，成為指導我們認知和行動的規則，並以此來理解他人行為。  單環思維陷阱:   一定程度上，越成功的人，他的模式越有效，越容易陷入單環思維陷阱。一旦環境發生變化，他的策略失靈時，會產生強烈的自我防衛意識，拒絕接受批評，將問題歸罪於環境或第三者，堅稱自己並沒有過錯（維護自己的模式）。 策略失靈，本提供了一個好的學習機會，但在這種單環的防衛心理機制下，他喪失了學習能力。  三果思維: 結果, 效果, 成果  三果導向思考: 增加Outcomes(三果)來評估結果, 質疑過程, 反思我們的信念與假設(模式).\n  結果, 效果, 成果:技術上Outcomes有三個層次\n   結果: 完成任務. 效果: 比上次做有什麼改進, 提升幅度. 成果: 個人有無成長, 通過做這件事取得什麼進步.  每日寫文章的三果: 寫作習慣的三果分析   結果: 完成篇500字以上的文章 效果: 這次比之前是否更清晰,更易懂, 格局變大? 成果: 經過寫這篇文章後, 獲得什麼進步, 解決什麼問題, 對某事是否有更深的理解, 寫作的目的是什麼, 是否是當前最重要的事.  三果核查輸出:   利用三果核查, 跳出系統本本身, 在「元系統」的更高層次觀察系統.  商業三效:   效率 (Efficient): doing something in a good, careful and complete way with no waste of time, money or energy 把事情做得好, 謹慎, 完整, 沒有額外浪費時間, 金錢, 能源. 效果 (Effective): producing the result that is wanted or intended; producing a successful result 生產想要或預期的成功結果 效益 (Economic): (of a process, a business or an activity) producing enough profit to continue 產生足夠利潤以繼續  工序即模式:   模式: 事物重複, 有規律地發生與完成. 工序自動化: 自動化模式, 成為我們行為模式與思維方式. 雙環學習: 三果能將自動化的模式轉為雙環學習, 將原本封閉的IPO系統轉化為開放的IPOO系統.  學習的IPO模型 信息輸入(Input):     每週的學習精力如何分配?    是否真的善用所有的學習渠道?    可否大幅提升現在的學習內容質量?    學習渠道實務:   做業務復盤, 紀錄實際工作中的領悟 閱讀學習, 讀書, 碎片化知識, 課程 行業交流諮詢, 高水平交流 產品學習, 頂級產品, 競爭對手, 行業的經典打法  學習質量提升實務:   閱讀的信息質量愈高, 學習效率愈高 高價值的真實信息鳳毛麟角, 定期更新閱讀源, 提升信息質量. 過去99%的PR文, 記者觀點; 只閱讀優秀創業者的業務復盤, 演講, 採訪.  信息處理(Process):     有不斷追問事物本質的習慣媽?    掌握了多少思維模型?    面對創業難題, 是否有自己的完備思考框架?    事物本質實務:   產品的本質, 營運的本質, 融資的本質, 品牌的本質 花時間討論本質問題, 討論清楚, 達成共識, 會提升決策質量. 如何一層層深度思考, 逐步挖掘深層次含義, 最終接近事情的本質.  思維模型實務:   數學, 工程學, 物理學, 生物學, 化學, 統計學, 社會學, 心理學, 經濟學. 經典思考框架, 對90%的問題都可做出優秀決策.  自我框架實務:   完整思考, 理性選擇.  信息輸出:     在用的是哪些輸出方式?    目前的學習深度真的足夠媽?    輸出方式實務:   與高段位的人聊天 被動學習: 聽講, 朗讀, 聽與看, 示範展示 主動學習: 小組討論, 實作演練, 轉教別人, 立即應用 聆聽\u0026ndash;\u0026gt;沈澱\u0026ndash;\u0026gt;傳播  學習深度實務:   被動學習留存率低, 應避免. 主動學習留存率高, 透過討論分享實踐, 達到學習深度. 自我探討, 自我復盤, 自我反思.  後記  到此摘錄了各種IPO模型的實踐. 從輸入, 處理, 輸出, 所搭建起的系統, 與環境互動, 得到反饋, 是我們在增強學習中對「認知能力」的建模. 藉由標準化這些建模, 許多部分得到了自動化, 也因此可以被逐漸優化, 達到更好的表現.\n  另外, 透過三果思維, 去看行動的結果, 效果, 成果, 於是就能夠fine tune系統的各種變數. 機器學習系統也是類似的邏輯, 能夠人工找出表現好的機器狀態. 這類的邏輯都考慮進去, 就能累積工程思維, 做出來的東西也就更有價值, 因為能解決更具體的問題.\n  透過這次的寫作, 對系統思維的掌握感覺又更確實了! 之後可以多思考將此IPO系統模型, 與Python的編程思維做搭配, 來迭代自己的認知模型！天天向上, 共勉之!\n  2022.01.18. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-18","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur020-%E6%B2%88%E6%80%9D%E8%BC%B8%E5%85%A5-%E8%99%95%E7%90%86-%E8%BC%B8%E5%87%BA%E6%A8%A1%E5%9E%8B/","series":["每日文章","編程思維"],"tags":["Python"],"title":"MUR020 沈思輸入-處理-輸出模型"},{"categories":[],"content":"從幼女戰記思考蘇德戰爭  紫式晦澀每日一篇文章第19天\n 前言   今天是2022年第17天, 全年第3週, 一月的第三個週一. 昨晚與今天一整天都在看「幼女戰記」, 看了動畫漫畫與電影版. 非常好看, 以前對戰爭的歷史沒這麼有興趣, 現在多了很多角度可以思考, 用今天的文章來研究看看「蘇德戰爭」.\n  今天的素材主要來自網路關於「蘇德戰爭」的種種資訊. 對歷史類的東西沒研究過, 來學習學習相關的文化.\n  蘇德戰爭背景與細節  定義: 蘇德戰爭（德國方面稱為東方戰線，德語：die Ostfront；蘇聯方面稱為偉大的衛國戰爭，俄語：Великая Отечественная Война，而「衛國戰爭」本指1812年的俄法戰爭）是第二次世界大戰期間蘇聯與納粹德國及雙方盟國之間發生的戰爭，時間從1941年6月22日德國開始進攻蘇聯、至1945年5月9日德國向蘇聯無條件投降為止。   戰前背景:\n   在20世紀30年代阿道夫·希特勒領導的納粹黨在德國取得執政，而英國、法國等西方國家採取的綏靖政策則更加助長了納粹德國的氣勢。 而此時的蘇聯總書記約瑟夫·史達林為實現自己的利益和德國簽署了「蘇德侵犯條約」。 該條約中包括了「秘密附屬議定書」，將波蘭、波羅的海三國、芬蘭以及東歐等國劃分為兩國的勢力範圍。  德國與蘇聯合作, 瓜分歐洲大陸:   1939年9月，德國與蘇聯聯合發動的波蘭戰役以及1940年的法國戰役之後，德國和義大利在1940年就很快就占領了中歐、西歐大陸、北歐和巴爾幹半島. 1941年6月初，德國控制了歐洲包括法國、波蘭西部、荷蘭、挪威、丹麥、比利時等16個國家的人力、物力資源，並且盟國除了義大利外有匈牙利、羅馬尼亞和保加利亞。 而這時的全世界，只有英國在獨自和德國、義大利作戰。 而此時，蘇聯在1939年9月蘇德瓜分波蘭之後從波蘭得到了它51%的領土，從羅馬尼亞拿走了南比薩拉亞和北布科維納，從芬蘭拿走了卡累利阿、薩拉、雷巴奇半島等領土。  蘇聯方面 德國發展更好, 蘇聯開始防範德國:   1930年代末的蘇聯經過十餘年的大規模經濟建設，工業產值已經躍居歐洲第一，但是生產品質和人民生活水準則遠不如納粹德國。 另外，蘇聯全國也剛從瘋狂的大清洗肅反運動中慢慢恢復正常的秩序。 在德國橫掃歐洲之時，史達林看到如此強大的德國必然會威脅到蘇聯的國家安全，便開始著手採取防範德國的系列措施   將蘇聯的重工業和軍工工業有計劃地遷移到烏拉爾山以東；    對德國和談，避免刺激德國；    穩住東方的大日本帝國，先是通過援助中國的抗日戰爭以牽制日本的軍隊，之後又轉變態度，於1941年4月和日本簽署《蘇日中立條約》；    建立「東方戰線」，增加戰略縱深等等。    蘇聯的東方戰線(Восточный фронт):侵略東歐:   在蘇聯的系列準備措施中，建立東方戰線是最具爭議的，在建立東方戰線的進程中，蘇聯根據《蘇德互不侵犯條約》中的秘密條款占領了約60萬平方公里的土地，將芬蘭、羅馬尼亞等國迅速地推向自己的對立面，還遭受到世界各國的普遍譴責。 且事實上東方戰線在戰爭中起到的作用也極其有限，蘇聯吞併的地區的人民大多反對蘇聯的統治，在德國入侵的時候有很多民眾都發起暴動趕走蘇軍並歡迎德軍的到來。  德國方面 德國西線戰事順利, 著手入侵蘇聯:   德國方面，西線戰事的順利進行，只有英國憑藉海洋的優勢持續抵抗（德國的入侵），讓希特勒感到有機會騰出手來對付東邊的蘇聯了. 而德國的情報機構對蘇聯的大大低估的錯誤判斷，也讓希特勒認為蘇聯是非常容易對付的國家，便開始著手制定入侵蘇聯的計劃，計劃代號：「巴巴羅薩計劃」。  巴巴羅薩計劃(Unternehmen Barbarossa):   巴巴羅薩計劃，德軍計畫以集中380萬兵力，以「閃電戰」分別從北、中、南3個方向實施迅猛而深遠的突擊，占領蘇聯的首都莫斯科、蘇聯第2和第3大城市列寧格勒和基輔等城市 在蘇聯西部地區把蘇軍的主力消滅，接著向蘇聯腹地長驅直入，進抵阿爾漢格爾斯克、伏爾加河、阿斯特拉罕一線，並用空軍摧毀烏拉爾工業區，從而擊敗蘇聯。  蘇聯對巴巴羅薩計畫的無防備:   擬定巴巴羅薩計畫半年後，蘇聯渾然不覺，還於1941年5月1日莫斯科紅場舉行閱兵式紀念國際勞動節 雖然英國等國和蘇聯間諜多次向史達林匯報「德國將在1941年夏進攻蘇聯」，但史達林認為英國和德國的戰爭分勝負之前，德軍還沒有能力進犯蘇聯。他甚至懷疑這是英國間諜為了將蘇聯拉入對德作戰的陷阱而捏造的。 而且蘇聯此時也因為正在準備進攻德國的「大雷雨計劃」，而沒有料到德軍即將進攻蘇聯。 史達林有一個進攻德國的「大雷雨計劃」，該計劃還比巴巴羅薩計劃更早策劃，只是由於蘇聯的戰爭準備還沒有達到進攻的要求而被德國的巴巴羅薩計劃先行一步。可見蘇聯對德國的進攻計劃是完全沒有防備的。  颱風行動 德軍進攻莫斯科:   9月30日，德軍中央軍團發動「颱風行動」，大舉進攻莫斯科。 德軍用於颱風行動莫斯科方向的兵力達到100萬、75個師、1,700輛坦克、1.4萬門火炮、1,400架飛機。 蘇軍在莫斯科以西300餘公里縱深內，建立了梯次配置的多道防禦地帶，有3個方面軍和一個戰役集群，總共125萬名兵力、共75個師、990輛坦克、7,600門火炮、677架作戰飛機擔任防禦，蘇共中央政治局、國防委員會、最高統帥部和總參謀部作戰組一概不離開莫斯科。 德軍陸軍兵分3路在沿途突破蘇軍的防禦線後逐步向莫斯科挺進，但是最猛烈的進攻遇到了最頑強的抵抗，進入10月2日之後莫斯科戰役正式打響，但此時蘇聯進入了秋冬時節，而這對蘇軍則非常有利。 11月7日冒著德軍的炮火，蘇聯在紅場舉行紀念十月革命勝利24周年的閱兵式，閱兵式後的蘇軍直接開赴前線。  蘇軍頂住德軍進攻:   經過浴血奮戰，蘇軍憑藉極其堅強的抵抗和熟悉的自然條件，蘇軍最終頂住了德軍進攻，並在11月30日將德軍中央集團軍的進攻成功阻止在北線到卡林努、中線在納羅—福明斯克和莫扎伊斯克、南線到圖拉城下並迫使中央集團軍停下來建造了幾道臨時防線， 於1941年12月5日之後轉入125萬人的大反攻，至1942年1月7日將參與颱風行動的德軍向西擊退至距離莫斯科250公里至320公里的地方，並使得德軍中央集團軍在1941年10月2日－1941年12月1日－1942年1月7日之間付出了35,757人陣亡、9,721人失蹤，共計45,478人陣亡和失蹤、總傷亡17.3萬人的代價。  幼女戰記中的相關資訊 帝國／萊希（帝国／ライヒ，Empire/ Reich）:   歷史定位從地理上來說類似是德意志帝國及奧匈帝國兩國合併成的國家，但主要影射的是德國。 帝國國土坐落於大陸中央四戰之地位置的新興工業大國，首都名為柏盧。 其在建國期間攻佔周遭國家的接鄰領土而埋下仇恨，並因國際情勢演變出強烈的民族主義和軍國主義，以及因地緣政治學而生的國防政策，擁有相當於軍事及工業命脈的西方工業地帶及低地工業地帶，並在大戰開始前與盧斯聯邦和義魯朵雅王國各自簽署互不侵犯條約及同盟協定（這裡參考了二戰時納粹德國的外交）。 魔導師大多為少數菁英風格，帝國一開始以陸軍的支援角色作為運用魔導戰力的方針，但隨著大戰逐漸激烈化而漸漸朝向獨立運用的菁英部隊發展。飛行魔導具的技術居於世界領先地位，動畫中的造型為類似傘兵副傘的前背包搭配裝在單腳的推進裝置。 漫畫的木偶劇中使用德國狼犬的形象。    與歷史上的德國「軍國主義」相符合; 這不是有軍隊的國家, 而是有國家的軍隊.\n   盧斯聯邦（ルーシー連邦，Russy Federation）:\n   歷史地位類似於蘇聯，與帝國東方接壤的共產主義國家，和帝國擁有帝國領奧斯特倫德的領土紛爭地區，首都名為莫斯科，為帝國東部方面軍和北方方面軍的主要假想敵。 並未簽署部分的國際法，理論上可隨意處置俘虜，前皇國政府和共和國有悠久的同盟傳統，並與列強共同維繫箝制帝國擴張的包圍網，但因近年來國內共產政府掌權而與共和國產生嫌隙，進而和帝國簽署互不侵犯條約，同時國內包含絕大多數魔導師和幹練軍官的保皇派因遭到新政府逮捕管制，所以軍隊嚴重缺乏魔導部隊及老練將校。 和帝國之間的東方戰場號稱為本次大戰死傷最為慘烈的戰區，戰後以五月九日作為偉大衛國戰爭紀念日。 漫畫的木偶劇中使用狐狸的形象。    歷史上5月9號是德國投降, 作品中是用了俄國的「偉大衛國戰爭」的名稱當紀念日.\n   後記  到此稍微比較了歷史上的蘇德戰爭與幼女戰記中的盧斯聯邦與帝國萊希. 有很多地方兩者都雷同, 之後可以慢慢用寫文章的方式思考學習.\n  以前對歷史不是很有興趣, 但看了幼女戰記之後, 開始想要了解各種喜歡的輕小說背後的文化基礎. 持續累積, 搬運資訊, 總結思考, 共勉之！\n  2022.01.17. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-17","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur019-%E5%BE%9E%E5%B9%BC%E5%A5%B3%E6%88%B0%E8%A8%98%E6%80%9D%E8%80%83%E8%98%87%E5%BE%B7%E6%88%B0%E7%88%AD/","series":["每日文章"],"tags":["幼女戰記"],"title":"MUR019 從幼女戰記思考蘇德戰爭"},{"categories":["物件導向編程"],"content":"沈思Python建構式  紫式晦澀每日一篇文章第18天\n 前言   今天是2022年第16天, 全年第3週, 一月的第三個週六. 今天來深思「構造Class」的細節思想, 讓思考昇華到更根本的原因上.\n  今天的素材主要來自各篇關於Python 建構式(constructor)的文章\n  Python構造式 構造式(Constructor)簡介:   在創建類的對象時, 使用 Python 編程語言中的構造函數(Constructor)，同時驗證對像是否有足夠數量的資源來執行任何類型的啟動任務。 一種特殊類型的函數或方法，其目的是初始化類的成員，通常分為兩種類型。 這些函數基本上是「參數化構造函數」和「非參數化構造函數」 。前者致力於考慮參數的想法，後者認為它不需要任何參數。  技法: 預設構造式\u0026參數化構造式 預設構造式(Default Constructor):    不接受任何參數。\n  在稱為 self 的默認構造函數的情況下存在默認參數。此參數指的是為此類創建的對象。\n  基本代碼\n  1class sample: 2 3 # default constructor 4 def __init__(self): 5 # initializing variable instance 6 self.number_variable=1001 7 8 # a method 9 def print_method(self): 10 print(“number variable : “,self.number_variable)  執行  1obj=sample() 2obj.print_method() 參數化構造式(Parameterized Constructor):   參數化構造函數接受其中的參數。 就像這裡的默認構造函數一樣，創建的第一個參數引用這個類的實例。 程序員需要並定義其餘參數以引用實例變量。 基本代碼  1class sample: 2 # parameterized constructor 3 def __init__(self , id , name , age , gender, doj , dob ): 4 self.id_value = id 5 self.name_value = name 6 self.age_value = age 7 self.gender_value = gender 8 self.doj_value = doj 9 self.dob_value = dob 10 # method to output attributes  11 def print_output(self): 12 print(“Id value :”, self.id_value) 13 print(“name_value :”, self.name_value) 14 print(“age_value :”, self.age_value) 15 print(“gender_value :”, self.gender_value) 16 print(“doj_value :”, self.doj_value) 17 print(“dob_value :”, self.dob_value)  執行  1obj1=sample(101,’Terry’,27,’male’,10072015,10071993) 2obj1.print_output() 心法: 構造式的工作原理-__init__()函數與自引用 __init__()函數:   該函數在相應類的對象實例創建時調用。 這個構造函數是使用 def 關鍵字來確認的，這與所有其他函數聲明非常相似。 在函數中的這些初始化函數聲明中另一個值得注意的事情將是前面和後綴的雙下劃線。  1def __init__(self,salary_arg) 自引用(Self Reference):   self 引用了物件本身(Object itself)。 self 可以指代與其所涉及的類相關的函數和變量。 必須是構造函數聲明中最重要的參數。 它表示期望指數與該對象的屬性一起使用。  1def __init__(self,Employee_name,Employee_id, Employee_age): 2 self.Employee_name = name; 3 self.Employee_id = id; 4 self.Employee_age = age 用法: 初始化, 實例變數 構造式的優點:   主優點: 在「初始化(Initialize)」有莫大幫助 實例變數(Instance variables): 使用建構式可以初始化的最後狀態 可以使用構造函數省略默認值初始化. 當 python 類創建物件時。, 造函數將是第一個開始執行的代碼段，這使得所有初始化都作為程序的第一個工作實例發生。 可以使用和不使用參數來啟動構造函數.  概覽__init__()方法  __init__()方法創造物件: __init__()方法是物件導向編程的核心, 因為其能「創造物件(create objects)」\n  物件導向:\n   面向物件寫程式（OOP）是一種編程範式，包括定義物件並與它們互動。 物件是複雜變數和函式的集合，可用於表示按鈕、飛機或人等真實實體。 要在Python中宣告、初始化和操作物件，我們使用類。 它們作為建立物件的模板。 下圖說明了這個想法：  類別是物件的克隆藍圖:   類(Class)定義並構建從中建立的所有物件。 類為物件(Object)工廠。 類使用方法(Method)和建構式(Constructor)來建立和定義物件。  特殊方法(Special methods):   特殊方法透過其名稱兩側的雙下劃線標識，例如__init__。 Python使用特殊方法來增強類的功能。 他們中的大多數人在後臺工作，並在程式需要時自動呼叫。 您不能顯式呼叫他們。 例如，當您建立新物件時，Python會自動呼叫__new__方法，而該方法又會呼叫__init__方法。 當您列印（）物件時，會呼叫__str__方法。 另一方面，使用者定義的方法，如stefi.run()，被顯式呼叫。  構造式(Constructor):   建構函式是程式呼叫物件建立的特殊方法。 建構函式在類中用於將資料成員初始化到物件。 特殊方法__init__是Python建構函式。  類別物件兩大功能: 屬性引用, 實例化  官方文檔的「類別物件(Class Object)」\n  類別物件核心功能: 類別物件的兩種核心操作, 為「屬性引用(Attribute References)」與「實例化(Instantiation)」 .\n  屬性引用(Attribute References):\n   使用Python中所有屬性引用的標準語法：obj.name 有效屬性名稱(Valid attribute names): 建立類物件時「類名稱空間(Class\u0026rsquo;s namespace)」中的所有名稱。 定義實例:  1class MyClass: 2 \u0026#34;\u0026#34;\u0026#34;A simple example class\u0026#34;\u0026#34;\u0026#34; 3 i = 12345 4 5 def f(self): 6 return \u0026#39;hello world\u0026#39;  這裡的MyClass.i(類屬性)與MyClass.f(類方法)是有效的屬性引用. MyClass.i(類屬性) 返回「正整數物件(Integer Object)」 MyClass.f(類方法) 返回「函數物件(Function Object)」 可以透過指定, 來感變MyClass.i的數值 __doc__也是有效特徵, 返回文檔\u0026quot;\u0026quot;\u0026quot;A simple example class\u0026quot;\u0026quot;\u0026quot;  實例化(Instantiation):   把「類別物件」視為「無參數函數」來產生「新的類別實例(new instance of the class)」. 實例:  1x = MyClass()  實例化(Instantiation): 實例化操作創建空物件. 類別創造「具有特定初始值的實例物件」, 所以需要定義特殊方法__init__() 實例:  1def __init__(self): 2 self.data = []  如果一個類別有定義__init__()方法, 實例化就會自動啟動. 也就是x = MyClass()在操作的事情.  建構式實例化實務 例子: 「學生」類別, 「學生成績」類別:   所謂的「類別」, 可以很融通. 例如「學生」類別包含一個學生的「個人資訊」; 「學生成績」類別包含了一個學生的「課業表現」. 實例  1# 定義「學生」類別, 屬性為「個人資訊」 2class student: 3 def __init__(self,name,age): 4 self.name=name 5 self.age=age 6 7# 定義「學生成績」類別, 屬性為「課業表現」, 方法有「計算平均成績」 8class student_marks: 9 def __init__(self,name,english,maths,science,sst): 10 self.name=name 11 self.english=english 12 self.maths=maths 13 self.science=science 14 self.sst=sst 15 16 def calculate_avg_marks(self): 17 total_marks=self.english+self.maths+self.science+self.sst 18 avg_marks=total_marks/4 19 return avg_marks 20 21# 實例化四個「學生成績」物件 22student1=student_marks(\u0026#34;Ashwini\u0026#34;,20,12,14,15) 23student2=student_marks(\u0026#34;Ashu\u0026#34;,10,18,16,9) 24student3=student_marks(\u0026#34;Sonu\u0026#34;,16,14,20,11) 25student4=student_marks(\u0026#34;Sushant\u0026#34;,20,20,20,20) 26 27# 計算四個「學生成績物件」的平均分數 28print(student1.calculate_avg_marks()) 29print(student2.calculate_avg_marks()) 30print(student3.calculate_avg_marks()) 31print(student4.calculate_avg_marks())   這個點很有趣, 適當的構造「類別」可以有效管理複雜度. 任何東西不要超過3個點, 超過我們就分解, 也是管理複雜系統的重要心法.\n   例子:「學生」, 「員工」都是「人」:\n   活用「繼承」的概念, 可以實踐「學生」, 「員工」都是「人」這句大白話 實例  1### 定義「人」類別 2class Person(): 3 def __init__(self,name): 4 print(\u0026#34;Person Init called.\u0026#34;) 5 self.name = name 6 7### 定義「學生」類別, 基於「人」類別 8class Student(Person): 9 def __init__(self, name): 10 Person.__init__(self, name) 11 print(\u0026#34;Student Init called.\u0026#34;) 12 self.name = name 13 def display(self): 14 print(\u0026#34;Student\u0026#34;,self.name) 15 16### 定義「員工」類別, 基於「人」類別  17class Employee(Person): 18 def __init__(self, name): 19 Person.__init__(self, name) 20 print(\u0026#34;Employee Init called.\u0026#34;) 21 self.name = name 22 def display(self): 23 print(\u0026#34;Employee\u0026#34;,self.name) 24 25### 實例化Vicky學生 26student = Student(\u0026#39;Vicky\u0026#39;) 27student.display() 28 29### 實例化Vikas員工 30employee= Employee(\u0026#39;Vikas\u0026#39;) 31employee.display()  更好的實例:  1### 定義「人」類別 2class Person(): 3 def __init__(self,name): 4 print(\u0026#34;Person Init called.\u0026#34;) 5 self.name = name 6 7### 定義「學生」類別, 繼承「人」類別 8### 利用「父類別」的「構造式 `__init__()` 9class Student(Person): 10 def __init__(self, name): 11 print(\u0026#34;Student Init called.\u0026#34;) 12 self.name = name 13 Person.__init__(self, name) 14 15 def display(self): 16 print(\u0026#34;Student\u0026#34;,self.name) 17 18student = Student(\u0026#39;Vicky\u0026#39;) 19student.display()   或用這種繼承思想, code可以更簡潔, 管理複雜度.\n   感覺寫論文是不是也能這樣呢? 要把哪些sentence pattern 給抽象畫出來呢? 如何建立資料庫呢? Python for Latex之類的呢?\n  Super()方法:\n   在「子類別(Subclass)」裡面使用方法super()可以得到「超類別(Superclass)」裡面的「暫時物件(temporary)」. 這個暫時物件的方法, 可以被使用. 實例:  1### 定義「長方體」類別 2class Cuboid: 3 ### 構造「長寬高」屬性 4 def __init__(self, length, width,height): 5 self.length = length 6 self.width = width 7 self.height=height 8 ### 方法計算表面積 9 def total_surface_area(self): 10 return 2*(self.length * self.width +self.width*self.height+self.length*self.height) 11 12### 「立方體」類別, 寫法一: 不使用繼承  13class Cube: 14 def __init__(self, length): 15 self.length = length 16 17 def total_surface_area(self): 18 return 6*self.length * self.length 19 20### 「立方體」類別, 寫法二: 使用繼承 21class Cube(Cuboid): 22 def __init__(self, length): 23 super().__init__(length,length,length) 24 25cuboid=Cuboid(5,4,3) 26print(cuboid.total_surface_area()) 27cube=Cube(5) 28print(cube.total_surface_area()) 後記  到此回顧了一些__init__()的技術細節, 以及實例思考「繼承」的一些用法.\n  感覺寫著寫著偏離了「構造式」的原主題, 但因為這邊的水很深, 所以100分鐘大概就cover這些內容. 我們寫作也要懂得取捨, 一步一腳印慢慢往前. 天天向上, 共勉之！\n  2022.01.16. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-16","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur018-%E6%B2%88%E6%80%9Dpython%E5%BB%BA%E6%A7%8B%E5%BC%8F/","series":["每日文章","編程思維"],"tags":["Python"],"title":"MUR018 沈思Python建構式"},{"categories":[],"content":"思考音程與音階  紫式晦澀每日一篇文章第17天\n 前言   今天是2022年第15天, 全年第2週, 一月的第三個週六. 今天要上音樂課, 把音程與音階的概念仔細想一次.\n  今天的素材主要網路搜尋各種關於音程與音階的資訊.\n   什么是音程？  音程之定義與各類音程的判別方式  維基百科  兩個基礎: 五線譜與十二平均律. 五線譜  五線譜 (Staff): 五線譜是一組, 由五條線與四個間組成的, 每個代表不同「音高 (Pitch)」.   組合五線譜 (System):\n   多個五線譜, 可以組成一個系統(System), 表達每個五線譜的樂器同時眼咒. 中括號(Bracket)代表同個樂器不同的五線譜的系統. 大括號(Brace)代表不同樂器組合成的系統.  總譜 (Grand Staff): 利用中括號聯合的兩個五線譜, 稱為「總譜」.  十二平均律 十二平均律(Equal temperament):音樂律式的一種，也是當今最主流的律式。   將一個八度平均分成十二等份，每等分稱為半音，音高八度音指的是頻率乘上二倍。 八度音的頻率分為十二等分，即是分為十二項的等比數列，也就是每個音的頻率為前一個音的2的12次方根   十二平均律表: 將主音設為a1(440Hz)，來計算所有音的頻率\n   音程名稱 間隔半音數 音程品質     純一度($A^1$) 0 極完全協和音程   增一度/小 二度 ($A\\sharp^{1}$//$B\\flat^{1}$) 1 不協和音程   大二度 (B^(1)) 2 不協和音程   小三度(C) 3 不完全協和音程   大三度 ($C\\sharp$) 4 不完全協和音程   純四度(D) 5 完全協和音程   增四度/減五度 ($D\\sharp^{1}$//$E\\flat^{1}$) 6 不協和音程   純五度(E) 7 完全協和音程   小六度(F) 8 不完全協和音程   大六度 ($F\\sharp$) 9 不完全協和音程   小七度(G) 10 不協和音程   大七度 ($G\\sharp$) 11 不協和音程   純八度(A) 12 極完全協和音程      從五線譜看十二平均律表\n   1）在度數為一的情況下，顯然，兩音的音高是一樣的，相隔的音數自然為零。最後將度數和音數一起考慮，我們把度數為一，音數為零的情況稱為：純一度。 2）在度數為二的情況下，兩音音高不同，相隔的音數有兩種情況。如果兩音是C和D，那麼它們相隔一個全音，我們稱音數為一；如果兩音是E和F，那麼它們相隔一個半音，我們稱音數為二分之一。最後將度數和音數一起考慮，我們把度數為二，音數為一的情況稱為：大二度。而把度數為二，音數為二分之一的情況稱為：小二度。 3）三度的情況跟二度是一致的。有大三度和小三度。 4）但四度與三度就不一致了！深層次的原因還是在於七個音名在十二平均律中分布的「不均勻」性。四度的分類不是大四度和小四度；而是純四度和增四度。 如果兩音是F和B，那麼它們相隔三個全音，我們稱音數為三。如果兩音是C和F，那麼它們相隔二又二分之一個全音，我們稱音數為二又二分之一。前者稱為增四度，後者稱為純四度。 為什麼不叫大四度和小四度呢？我覺得可以這麼理解。四度的情況下，音數為三的情況只有一種，即F和B。而音數為二又二分之一的情況則有六種（C和F；D和G等等）。前者很特別，後者很常見，所以把後者稱為是「純」的。從統計上講，由於七音在十二平均律上分布的「不均勻性」，導致後者出現的概率大得多（度數為四，音數為二又二分之一），故命名為「純」。那麼前者由於音數比「純」多了，所以命名為「增」。這只是一種「可能」的理解方式。由於我不是音樂專業出身，這種理解方法也許是不正確的，我並不知道在音樂專業上是如何理解這件事情的。 5）五度的話，分為減五度（音數為三）和純五度（音數為三又二分之一）。與四度的分法類似。 6）六度的話，則分為小六度（音數為四）和大六度（音數為四又二分之一）。與二度、三度的分法一致。 7）七度與六度類似，分小七度和大七度。 8）八度只有純八度，與一度的分法類似。  音程的大小與性質 音程大小: 音程, 音級, 音數  定義音程(Interval): 音程（interval），指的是一個特定樂音體系中，兩个音之間音高的距離。\n  定義音級(來自五線譜): 音級(Interval Number)是指兩音之間包括幾個基本音。在樂理上，習慣以「度」來表示兩音之間的距離。 The number of an interval is the number of letter names or staff positions (lines and spaces) it encompasses, including the positions of both notes forming the interval.\n  五線譜上的音級: 在五線譜(Staff)中，每個「線(Lines)」、每個「間(Spaces)」都代表一個音級，當兩個音在同一個「線」或「間」時，稱為一度。若兩個音是在相鄰的「間」與「線」上，就稱為二度。其它度數以此類推。   定義音數(來自十二平均律): 半音數目是指音程內所含半音(Semitone)的個數。西方樂理中雖然有全音和半音的概念，但計算音程時，一直來都只採用單一的量度單位－半音。\n  比較音級與音數:\n   描述「音程」共有兩個維度：度數和音數。 度數是指兩個音在五線譜上的距離（度量單位為：線、間）。 音數是指兩個音在十二平均律上的距離（度量單位為：全音、半音）。  音程性質: 完全, 大, 小, 增, 倍增, 減, 倍減 音程性質(Interval Quality): 音程的性質, 有七種:     Perfect(P) : 完全音程    major(M): 大音程    minor(m): 小音程    augmented(A): 增音程    double augmented: 倍增音程    diminished(d): 減音程    double diminished: 倍減音程    完全音程 (Perfect Interval):   完全音程（Perfect Intervals）：完全音程只有四種，包括：同度（Unison）、完全四度（Perfect Forth）、完全五度（Perfect Fifth）與完全八度（Perfect Octave）。 「完全音程」之所以稱作完全音程，是因為在中世紀與文藝復興時期的音樂中，這四個音程最適合用於一樂曲的終止式，這包含了一樂句裡頭較小型的與樂段中較規模的終止式。   大音程(Major Interval):   大音程只有四種，包括：大二度、大三度、大六度與大七度。 「大音程」之所以稱作「大音程」是因為它們來自於一大調音階中，各個音（扣掉上述四個完全音程之後）與主音所形成的關係。   小音程(Minor Interval):   小音程：小音程只有四種，包括：小二度、小三度、小六度與小七度。 「小音程」之所以稱作「小音程」是因為它們來自於一小調音階中，各個音（扣掉上述四個完全音程之後）與主音所形成的關係。   增音程(Augmented Interval):   增音程：比完全音程以及大音程寬一個半音的音程，稱為「增音程」。 增音程共有八種。 「增音程」之所以稱作增音程，係由於它們是以上述之完全音程與大音程作為基礎，擴大一個半音後所得之音程。  倍增音程(Double Augmented Interval):   倍增音程：比增音程再寬一個半音的音程，稱為「倍增音程」。 倍增音程共有八種。 「倍增音程」之所以稱作倍增音程，係由於它們是以上述之完全音程與大音程作為基礎，擴大兩個半音後所得之音程。  減音程(Diminish Interval):   減音程：比完全音程以及小音程窄一個半音的音程。 「減音程」之所以稱作減音程，係由於它們是以上述之完全音程與小音程作為基礎，減小一個半音後所得之音程。  倍減音程(Double Diminish Interval):   倍減音程：比減音程再窄一個半音的音程。 「倍減音程」之所以稱作倍減音程，係由於它們是以上述之完全音程與大音程作為基礎，擴大兩個半音後所得之音程。  協和音程與不協和音程:   1）極完全協和音程：純一、八度。就是聽起來就像聽同一個音一樣。 2）完全協和音程：純四、五度。 3）不完全協和音程：大、小三度，大、小六度。聽起來感覺還不錯，悅耳。 4）不協和音程：聽起來不和諧。大、小二度，大、小七度，所有的增、減、倍增、倍減音程。 前三類聽起來都悅耳，統稱協和音程。 這四類音程是「和聲學」的基石，判斷音程的協和性是非常重要的。  音階: 自然音階與半音音階 自然音階  音階(Music Scale): 按照泛音列(Harmonic series)或音高(Pitch)排列，並因其規律形成循環的一系列音符。一個音階中的音符按照音高的上升而排列便是上行音階，若音符按照音高的下降而排列則是下行音階。\n  自然音階(Diatonic scale): 自然音階, 是任何包含五個「全音(Whole tones)」與兩個「半音(Semitones)」, 共十二個半音, 的「七音音階 (Heptatonic scale)」.\n   唱名: C–D–E–F–G–A–B\n 七音高 (Seven pitches):自然音階的七音高, 可以由「一串六個完全五度 (chain of six perfect fifths)」來得到   隔五度: F–C–G–D–A–E–B\nFa-Do-So-Re-La-Mi-Si\n  倒轉格五度: B-E-A-D-G-C-F\nSi-Mi-La-Re-So-Do-Fa\n  完全五度圈\n 半音音階 半音音階(Chromatic Scale): 有12個不同音高順序排列的音階. 稱為十二音音階(twelve-tone scale), 每個差半音.  鋼琴12健 七個白鍵, 五個黑鍵.  後記  到此整理思考了音程與音階的相關資訊. 從五線譜與十二平均律, 對應了自然音階的七音音階與半音音階的十二音音階. 在音程的大小與性質方面, 音程是兩個音之間的音高, 音級是兩個音之間包含多少個自然音(七音系統), 音數則是中間包含多少個半音(十二音系統).\n  對於大音程與小音程, 之前有口訣是「全全半全全全半」與「全半全全半全全」兩種. 據說是對應大調音階與小調音階. 這個部分還很陌生, 之後與老師討論增強理解.\n  這篇文章把各種複雜的音樂基礎知識做了爬梳, 非常好！維持寫文章整理資訊的習慣, 可以有效地加深每次問題的深度！共勉之！\n  2022.01.15. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-15","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur017-%E6%80%9D%E8%80%83%E9%9F%B3%E7%A8%8B%E8%88%87%E9%9F%B3%E9%9A%8E/","series":["每日文章"],"tags":["音樂"],"title":"MUR017 思考音程與音階"},{"categories":["合成數據","可信任的AI"],"content":"思考Chase合成數據技術細節  紫式晦澀每日一篇文章第16天\n 前言   今天是2022年第14天, 全年第2週, 一月的第二個週五. 一月也過了一半, 時間真快！\n  今天的素材主要來自Chase關於synthetic data的技術介紹 . 藉由學習裡面做事邏輯來思考合成數據的技術細節.\n  大框架與工作流: 七步從真實到合成  背景: 研究開發演算法, 以合成逼真的合成數據集. 有四類金融任務: 反洗錢, 客戶旅程事件, 市場執行資料, 付款與詐欺偵測.\n  技術文章: 文章為Generating Synthetic Data in Finance: Opportunities, Challenges and Pitfalls . 共十頁, 可系統讀讀學習.\n  工作流: 共有七步\n   a. 計算「真實數據的度量(metrics for the real data)」 b. 「發展合成器 (Develop a Generator)」, 可基於統計方法或基於代理人的模擬. c. 使用真實數據「校準合成器 (Calibrate the Generator) d. 「跑合成器(Run the Generator)」來生成合成數據 e. 計算「合成數據的度量(metrics for the synthetic data)」 f. 真實數據與合成數據「比較度量(Compare the metrics)」 g. 「改良合成器 (Refine the Generator)」來改進比較的度量  實際金融場景: 反洗錢, 客戶旅程, 市場執行, 付款資料詐欺偵測 反洗錢（AML）: 洗錢是將來自非法活動的資金引入金融系統以將其用於合法或非法目的的過程。 這些資料代表了合法客戶和從事洗錢活動的客戶與金融機構的高級別互動的順序。 當前資料包含銀行客戶相關活動的狀態和行動對。 例如開立賬戶、進行交易、付款、提款、購買等。 資料是透過執行人工智慧規劃-執行模擬器生成的。   References\n Generating Synthetic Data in Finance: Opportunities, challenges and pitfalls. S Assefa, D Dervovic, M Mahfouz, R Tillman, P Reddy, T Balch and M Veloso. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020. Also in NeurIPS 2019 Workshop on AI in Financial Services Simulating and classifying behavior in adversarial environments based on action-state traces: An application to money laundering, D Borrajo, M Veloso, S Shah. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020. Also in arXiv preprint arXiv:2011.01826, 2020   客戶旅程活動: 客戶旅程事件代表了低階零售銀行客戶與銀行互動的順序。 事件的示例型別包括登入Web應用程式、付款、從自動取款機取款。 資料是透過執行人工智慧規劃執行模擬器並將輸出規劃跟蹤轉換為表格格式生成的。   References\n Generating Synthetic Data in Finance: Opportunities, challenges and pitfalls. S Assefa, D Dervovic, M Mahfouz, R Tillman, P Reddy, T Balch and M Veloso. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020. Also in NeurIPS 2019 Workshop on AI in Financial Services Domain-independent generation and classification of behavior traces. D Borrajo and M Veloso. arXiv preprint arXiv:2011.02918.   市場執行資料: 綜合限額訂單簿資料，描述公共證券交易所各種市場參與者的一系列金融工具（股票）買賣訂單。 具體來說，這些資料將包含一段時間內訂單的訊息和快照。 這些資料代表了不同市場制度下高流動性股票模擬資料的N個交易日（例如，趨勢上升/下降，高/低波動）。   References\n Generating Synthetic Data in Finance: Opportunities, challenges and pitfalls. S Assefa, D Dervovic, M Mahfouz, R Tillman, P Reddy, T Balch and M Veloso. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020. Also in NeurIPS 2019 Workshop on AI in Financial Services Get Real: Realism Metrics for Robust Limit Order Book Market Simulations. S. Vyetrenko et al. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020.   用於欺詐檢測的付款資料: 從以主題為中心的角度代表交易的資料，目的是識別欺詐交易。 這些資料包含大量交易型別，代表正常活動以及以預定義概率引入的異常/欺詐活動。 資料是透過執行人工智慧規劃執行模擬器並將輸出規劃跟蹤轉換為表格格式生成的。 資料生成模型的引數包括客戶端數量、時間持續時間和欺詐概率。   References\n Generating Synthetic Data in Finance: Opportunities, challenges and pitfalls. S Assefa, D Dervovic, M Mahfouz, R Tillman, P Reddy, T Balch and M Veloso. Proceedings of the 1st International Conference on AI in Finance (ICAIF), 2020. Also in NeurIPS 2019 Workshop on AI in Financial Services Domain-independent generation and classification of behavior traces. D Borrajo and M Veloso. arXiv preprint arXiv:2011.02918.   合成器技術: 表格數據, 流數據, 金融時間序列, 非結構化圖片與聲音. 生成的資料種類: 主要需要合成的數據具有「隱私保證(Privacy guarantees)」. 產生的數據類型有:     表格數據 (Tabular Data)    合成金融時間序列 (Synthetic financial time series)    具有隱私保證的流數據 (Stream data with privacy guarantees)    非結構化數據(Unstructured Data)    表格數據 (Tabular Data): 有很多被研究的方法.     合成數據定義語言(SDDL; Synthetic data definition language). 缺點: 無隱私保證.    經典機器學習分類器 (Classical machine learning classifiers): 支撐向量機, 隨機森林. 缺點: 準確度高的模型, 容易洩露隱私, 也無法調整隱私參數.    貝氏差分隱私合成數據(Bayesian differential privacy synthetic data). 有效. 缺點: 不易規模化    耦合(Copula): 用直方圖產生分佈相同的合成數據. 缺點: 不易規模化.    Gibbs取樣 (Gibbs sampling): 強隱私保證, 容易規模化. 缺點: 只限定於類別變數.    隱私保護生成數據的共通限制:   難以規模化: 大多數差分隱私框架將給定表的一行表示為長度等於域大小的位串，它在表的列數中呈指數增長。 這種表示很快變得不實用。 高維度資料集很稀疏, 加了噪聲加密後就喪失了訊號: 這種表示的第二個限制是大多數高維數據集非常稀疏，導致添加噪聲以生成隱私完全沖刷了真實數據，使得發布的數據集不適合作為真實數據集的近似值。 在 Zhang ([25] Jun Zhang. Algorithms for Synthetic Data Release under Differential Privacy. PhD thesis, Nanyang Technological University, 2016.)中可以找到對這些限制的更徹底的討論。   基於代理人建模(ABM; Agent-based modelling): 建模「銀行付款處理系統(bank\u0026rsquo;s payment processing system), 調查惡意事件的宏觀影響. 要校準模型來滿足隱私限制, 但還沒有被廣泛研究.\n  合成金融時間序列 (Synthetic financial time series):\n   有很多於差分隱私資料流合成金融時間序列的研究, 但很少有隱私保護. 一般是用時間序列模型, 最大似然方法來做. 容易做, 好解釋, 但需要強假設, 無法再產生各種金融時間序列的統計特徵. 近代的方法有QuantGAN來合成股票的對數利潤. 但沒有提供隱私保證, 無法記得資料的特徵. 基於代理人模擬, 會重現金融市場的動態, 以導出金融時間序列.  具有隱私保證的流數據 (Stream data with privacy guarantees):   流數據: bit string. 有很多細節, 可以使用到隱私. 可以跟之前洗牌的隱私工作比較, 來做各種研究.  非結構化數據(Unstructured Data):   產生「圖片(images)」與「聲音(audio)」的差分隱私合成數據. 這些方法還有很多神經網路的問題未突破. 這些方法是在個人層級保護資料, 但這種隱私保護不夠強.  噪音與隱私權衡: 如何以最優的方式權衡噪音與隱私? ([9] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in private data analysis. In Shai Halevi and Tal Rabin, editors, Theory of Cryptography, pages 265–284, Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.)  後記  延伸閱讀: 在MUR012 合成數據於Chase銀行的金融應用 我們有討論過金融科技的應用. 當初的場景洞察沒有提供太多詳細解釋, 今天的文章補齊了這個方面的缺漏.\n  到此翻譯思考了Chase關於synthetic data的技術介紹 中的技術細節. 這次寫完文章覺得對具體場景有更加認識. 其實, 現在的元宇宙中的金融行為非常多, 而各種金融機構也都有記錄各種數據. 在隱私保護的驅動下, 如何做新一個時代的資料科學, 這是一個重要值得研究的問題, 我覺得很有意思.\n  之後寫文章可以往更細緻的論文去寫. 現在覺得對「形式化描述與結果」做「知識卡片」就可以, 對「文字化邏輯與論證」做「豆腐塊文章」的效果會更大. 的確, 我們要根據論據的不同做不同的處理, 才會有更好的工作流.\n  寫文章真的是思考最好的方式. 每一次的輸入, 範式處理,轉成輸出, 都讓我們更具體的將資訊以自己最適合的形式儲備為知識. 三十代的結構與價值之魅, 共勉之！\n  2022.01.14. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-14","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur016%E6%80%9D%E8%80%83chase%E5%90%88%E6%88%90%E6%95%B8%E6%93%9A%E6%8A%80%E8%A1%93%E7%B4%B0%E7%AF%80/","series":["每日文章","編程思維"],"tags":["金融科技"],"title":"MUR016 思考Chase合成數據技術細節"},{"categories":["物件導向編程"],"content":"從物件導向思考線性迴歸分析  紫式晦澀每日一篇文章第15天\n 前言   今天是2022年第14天, 全年第2週, 一月的第二個週四. 昨日生成自己的「元工作流」以後, 感覺安排任務好很多, 可以更有精力去規劃任務!\n  今天的素材主要來自Datacamp課程-Object-Oriented Programming in Python 結合之前的研究經驗. 目標是用物件導向編程的角度來重新思考線性回歸方法.\n  物件導向基礎: 克隆的藍圖 編程範式: 從單純系統到複雜系統 過程式編程: 我們那個年代一開始程式教育的編程模式.   過程式程序設計（英語：Procedural programming），又稱過程化編程，一種編程典範，衍生自指令式編程，有時會被視為是同義語。 主要要採取過程調用或函數調用的方式來進行流程控制。  過程式編程的好處: 比較符合我們傳統的數學教育, 但對現代的Python編程就產生gap了.   Code as a sequence of steps 代碼=一串動作 Great for data analysis 適合資料分析   物件導向編程: 在物件導向程式編程裡，電腦程式會被設計成彼此相關的物件。 面向對象程序設計可以看作一種在程序中包含各種獨立而又互相調用的對象的思想.\n  物件導向編程的好處: 我們這個時代的編程思維.\n   Code as interactions of objects 代碼=物件之間的互動 Great for building frameworks and tools 建立框架與工具 Maintainable and reusable code! 好維護, 好重複使用   單純系統: 過程式編程 複雜系統: 物件導向編程\n 物件 as 資料結構; 類 as 藍圖  原則: 封裝 (Encapsulation): bundling data with code operating on it. 將「資料」與「作用他的代碼」捆綁在一起.\n  物件(Object): 定義物件, 思考其會有的狀態, 以及他需要的行為.\n   物件 = 狀態 + 行為 Object = State + Behavior\n 類(Class): 物件可能的「狀態」與「行為」的藍圖. Blueprint for objects outlining possible states and behaviors.  物件導向Python實踐: 狀態, 屬性, 變數; 行為, 方法, 函數. Python中的物件: 找到任何看到的Python code背後的藍圖.   Python中什麼都是「物件」. Everything in Python is an object. 所有物件背後都有「類」. Every object has a class. 用內建函數type()可以找到「物件背後的類」. Use type() to find the class  物件=狀態+行為; 狀態 as 物件屬性; 行為 as 物件方法 召喚Python物件資訊: 利用obj.可以讀取「屬性(attributes)」與「方法 (methods)」.  物件=狀態+行為; 數學物件=變數+函數; 編程物件=屬性+方法 類比物件導向編程與數學: 屬性對應變數; 方法對應函數   attribute 對應 variables 對應 obj.my_attribute method 對應 function() 對應 obj.my_method() 用內建函數dir()查詢所有的屬性與方法.   練習使用type()與dir()\n 以物件導向理解線性迴歸模組: type(), dir()與help() 實踐物件導向思維於LinearRegression模組:  1# Program 01: Run linear regression. 2import numpy as np 3from sklearn.linear_model import LinearRegression 用type(LinearRegression)找到線性模型的藍圖(狀態與行為的封裝) 執行type(LinearRegression): 會跑出很簡潔的abc.ABCMeta  1type(LinearRegression) 2abc.ABCMeta 用dir(LinearRegression)找到線性模型的「狀態」與「行為」 執行dir(LinearRegression): 會跑出一大串類方法(class methods)! 其中有私有方法(Private method)也有公用方法(Public method).  1dir(LinearRegression) 2[\u0026#39;__abstractmethods__\u0026#39;, 3 \u0026#39;__class__\u0026#39;, 4 \u0026#39;__delattr__\u0026#39;, 5 \u0026#39;__dict__\u0026#39;, 6 \u0026#39;__dir__\u0026#39;, 7 \u0026#39;__doc__\u0026#39;, 8 \u0026#39;__eq__\u0026#39;, 9 \u0026#39;__format__\u0026#39;, 10 \u0026#39;__ge__\u0026#39;, 11 \u0026#39;__getattribute__\u0026#39;, 12 \u0026#39;__getstate__\u0026#39;, 13 \u0026#39;__gt__\u0026#39;, 14 \u0026#39;__hash__\u0026#39;, 15 \u0026#39;__init__\u0026#39;, 16 \u0026#39;__init_subclass__\u0026#39;, 17 \u0026#39;__le__\u0026#39;, 18 \u0026#39;__lt__\u0026#39;, 19 \u0026#39;__module__\u0026#39;, 20 \u0026#39;__ne__\u0026#39;, 21 \u0026#39;__new__\u0026#39;, 22 \u0026#39;__reduce__\u0026#39;, 23 \u0026#39;__reduce_ex__\u0026#39;, 24 \u0026#39;__repr__\u0026#39;, 25 \u0026#39;__setattr__\u0026#39;, 26 \u0026#39;__setstate__\u0026#39;, 27 \u0026#39;__sizeof__\u0026#39;, 28 \u0026#39;__str__\u0026#39;, 29 \u0026#39;__subclasshook__\u0026#39;, 30 \u0026#39;__weakref__\u0026#39;, 31 \u0026#39;_abc_impl\u0026#39;, 32 \u0026#39;_check_feature_names\u0026#39;, 33 \u0026#39;_check_n_features\u0026#39;, 34 \u0026#39;_decision_function\u0026#39;, 35 \u0026#39;_estimator_type\u0026#39;, 36 \u0026#39;_get_param_names\u0026#39;, 37 \u0026#39;_get_tags\u0026#39;, 38 \u0026#39;_more_tags\u0026#39;, 39 \u0026#39;_preprocess_data\u0026#39;, 40 \u0026#39;_repr_html_\u0026#39;, 41 \u0026#39;_repr_html_inner\u0026#39;, 42 \u0026#39;_repr_mimebundle_\u0026#39;, 43 \u0026#39;_set_intercept\u0026#39;, 44 \u0026#39;_validate_data\u0026#39;, 45 \u0026#39;fit\u0026#39;, 46 \u0026#39;get_params\u0026#39;, 47 \u0026#39;predict\u0026#39;, 48 \u0026#39;score\u0026#39;, 49 \u0026#39;set_params\u0026#39;] 用help(LinearRegression)找到「公用」的屬性與方法 公用方法(Public Method): 注意沒加底線的那些方法, 就是我們讀官方指南會先出現的, 給「用戶」所使用的方法\n1 \u0026#39;fit\u0026#39;, 2 \u0026#39;get_params\u0026#39;, 3 \u0026#39;predict\u0026#39;, 4 \u0026#39;score\u0026#39;, 5 \u0026#39;set_params\u0026#39; 這些與官方API解釋的方法一致: 執行help(LinearRegression): 會出現詳細的文檔, 對公用的屬性與方法做詳細解釋  1HelponclassLinearRegressioninmodulesklearn.linear_model._base:23classLinearRegression(sklearn.base.MultiOutputMixin,sklearn.base.RegressorMixin,LinearModel)4|LinearRegression(*,fit_intercept=True,normalize=\u0026#39;deprecated\u0026#39;,copy_X=True,n_jobs=None,positive=False)5|6|OrdinaryleastsquaresLinearRegression.7|8|LinearRegressionfitsalinearmodelwithcoefficientsw=(w1,...,wp)9|tominimizetheresidualsumofsquaresbetweentheobservedtargetsin10|thedataset,andthetargetspredictedbythelinearapproximation.11|12|Parameters13|---------- 14| fit_intercept : bool, default=True 15|Whethertocalculatetheinterceptforthismodel.Ifset16|toFalse,nointerceptwillbeusedincalculations17|(i.e.dataisexpectedtobecentered).18|19|normalize:bool,default=False20|Thisparameterisignoredwhen``fit_intercept``issettoFalse.21|IfTrue,theregressorsXwillbenormalizedbeforeregressionby22|subtractingthemeananddividingbythel2-norm.23|Ifyouwishtostandardize,pleaseuse24|:class:`~sklearn.preprocessing.StandardScaler`beforecalling``fit``25|onanestimatorwith``normalize=False``.26|27|..deprecated::1.028|`normalize`wasdeprecatedinversion1.0andwillbe29|removedin1.2.30|31|copy_X:bool,default=True32|IfTrue,Xwillbecopied;else,itmaybeoverwritten.33|34|n_jobs:int,default=None35|Thenumberofjobstouseforthecomputation.Thiswillonlyprovide36|speedupincaseofsufficientlylargeproblems,thatisiffirstly37|`n_targets\u0026gt;1`andsecondly`X`issparseorif`positive`isset38|to`True`.``None``means1unlessina39|:obj:`joblib.parallel_backend`context.``-1``meansusingall40|processors.See:term:`Glossary\u0026lt;n_jobs\u0026gt;`formoredetails.41|42|positive:bool,default=False43|Whensetto``True``,forcesthecoefficientstobepositive.This44|optionisonlysupportedfordensearrays.45|46|..versionadded::0.2447|48|Attributes49|---------- 50| coef_ : array of shape (n_features, ) or (n_targets, n_features) 51|Estimatedcoefficientsforthelinearregressionproblem.52|Ifmultipletargetsarepassedduringthefit(y2D),this53|isa2Darrayofshape(n_targets,n_features),whileifonly54|onetargetispassed,thisisa1Darrayoflengthn_features.55|56|rank_:int57|Rankofmatrix`X`.Onlyavailablewhen`X`isdense.58|59|singular_:arrayofshape(min(X,y),)60|Singularvaluesof`X`.Onlyavailablewhen`X`isdense.61|62|intercept_:floatorarrayofshape(n_targets,)63|Independentterminthelinearmodel.Setto0.0if64|`fit_intercept=False`.65|66|n_features_in_:int67|Numberoffeaturesseenduring:term:`fit`.68|69|..versionadded::0.2470|71|feature_names_in_:ndarrayofshape(`n_features_in_`,)72|Namesoffeaturesseenduring:term:`fit`.Definedonlywhen`X`73|hasfeaturenamesthatareallstrings.74|75|..versionadded::1.076|77|SeeAlso78|-------- 79| Ridge : Ridge regression addresses some of the 80|problemsofOrdinaryLeastSquaresbyimposingapenaltyonthe81|sizeofthecoefficientswithl2regularization.82|Lasso:TheLassoisalinearmodelthatestimates83|sparsecoefficientswithl1regularization.84|ElasticNet:Elastic-Netisalinearregression85|modeltrainedwithbothl1andl2-normregularizationofthe86|coefficients.87|88|Notes89|----- 90| From the implementation point of view, this is just plain Ordinary 91|LeastSquares(scipy.linalg.lstsq)orNonNegativeLeastSquares92|(scipy.optimize.nnls)wrappedasapredictorobject.93|94|Examples95|-------- 96| \u0026gt;\u0026gt;\u0026gt; import numpy as np 97|\u0026gt;\u0026gt;\u0026gt;fromsklearn.linear_modelimportLinearRegression98|\u0026gt;\u0026gt;\u0026gt;X=np.array([[1,1],[1,2],[2,2],[2,3]])99|\u0026gt;\u0026gt;\u0026gt;# y = 1 * x_0 + 2 * x_1 + 3 100|\u0026gt;\u0026gt;\u0026gt;y=np.dot(X,np.array([1,2]))+3101|\u0026gt;\u0026gt;\u0026gt;reg=LinearRegression().fit(X,y)102|\u0026gt;\u0026gt;\u0026gt;reg.score(X,y)103|1.0104|\u0026gt;\u0026gt;\u0026gt;reg.coef_105|array([1.,2.])106|\u0026gt;\u0026gt;\u0026gt;reg.intercept_107|3.0...108|\u0026gt;\u0026gt;\u0026gt;reg.predict(np.array([[3,5]]))109|array([16.])110|111|Methodresolutionorder:112|LinearRegression113|sklearn.base.MultiOutputMixin114|sklearn.base.RegressorMixin115|LinearModel116|sklearn.base.BaseEstimator117|builtins.object118|119|Methodsdefinedhere:120|121|__init__(self,*,fit_intercept=True,normalize=\u0026#39;deprecated\u0026#39;,copy_X=True,n_jobs=None,positive=False)122|Initializeself.Seehelp(type(self))foraccuratesignature.123|124|fit(self,X,y,sample_weight=None)125|Fitlinearmodel.126|127|Parameters128|---------- 129| X : {array-like, sparse matrix} of shape (n_samples, n_features) 130|Trainingdata.131|132|y:array-likeofshape(n_samples,)or(n_samples,n_targets)133|Targetvalues.WillbecasttoX\u0026#39;s dtype if necessary. 134| 135| sample_weight : array-like of shape (n_samples,), default=None 136| Individual weights for each sample. 137| 138| .. versionadded:: 0.17 139| parameter *sample_weight* support to LinearRegression. 140| 141| Returns 142| ------- 143| self : object 144| Fitted Estimator. 145| 146| ---------------------------------------------------------------------- 147| Data and other attributes defined here: 148| 149| __abstractmethods__ = frozenset() 150| 151| ---------------------------------------------------------------------- 152| Data descriptors inherited from sklearn.base.MultiOutputMixin: 153| 154| __dict__ 155| dictionary for instance variables (if defined) 156| 157| __weakref__ 158| list of weak references to the object (if defined) 159| 160| ---------------------------------------------------------------------- 161| Methods inherited from sklearn.base.RegressorMixin: 162| 163| score(self, X, y, sample_weight=None) 164| Return the coefficient of determination of the prediction. 165| 166| The coefficient of determination :math:`R^2` is defined as 167| :math:`(1 - \\frac{u}{v})`, where :math:`u` is the residual 168| sum of squares ``((y_true - y_pred)** 2).sum()`` and :math:`v` 169| is the total sum of squares ``((y_true - y_true.mean()) ** 2).sum()``. 170| The best possible score is 1.0 and it can be negative (because the 171| model can be arbitrarily worse). A constant model that always predicts 172| the expected value of `y`, disregarding the input features, would get 173| a :math:`R^2` score of 0.0. 174| 175| Parameters 176| ---------- 177| X : array-like of shape (n_samples, n_features) 178| Test samples. For some estimators this may be a precomputed 179| kernel matrix or a list of generic objects instead with shape 180| ``(n_samples, n_samples_fitted)``, where ``n_samples_fitted`` 181| is the number of samples used in the fitting for the estimator. 182| 183| y : array-like of shape (n_samples,) or (n_samples, n_outputs) 184| True values for `X`. 185| 186| sample_weight : array-like of shape (n_samples,), default=None 187| Sample weights. 188| 189| Returns 190| ------- 191| score : float 192| :math:`R^2` of ``self.predict(X)`` wrt. `y`. 193| 194| Notes 195| ----- 196| The :math:`R^2` score used when calling ``score`` on a regressor uses 197| ``multioutput=\u0026#39;uniform_average\u0026#39;`` from version 0.23 to keep consistent 198| with default value of :func:`~sklearn.metrics.r2_score`. 199| This influences the ``score`` method of all the multioutput 200| regressors (except for 201| :class:`~sklearn.multioutput.MultiOutputRegressor`). 202| 203| ---------------------------------------------------------------------- 204| Methods inherited from LinearModel: 205| 206| predict(self, X) 207| Predict using the linear model. 208| 209| Parameters 210| ---------- 211| X : array-like or sparse matrix, shape (n_samples, n_features) 212| Samples. 213| 214| Returns 215| ------- 216| C : array, shape (n_samples,) 217| Returns predicted values. 218| 219| ---------------------------------------------------------------------- 220| Methods inherited from sklearn.base.BaseEstimator: 221| 222| __getstate__(self) 223| 224| __repr__(self, N_CHAR_MAX=700) 225| Return repr(self). 226| 227| __setstate__(self, state) 228| 229| get_params(self, deep=True) 230| Get parameters for this estimator. 231| 232| Parameters 233| ---------- 234| deep : bool, default=True 235| If True, will return the parameters for this estimator and 236| contained subobjects that are estimators. 237| 238| Returns 239| ------- 240| params : dict 241| Parameter names mapped to their values. 242| 243| set_params(self, **params) 244| Set the parameters of this estimator. 245| 246| The method works on simple estimators as well as on nested objects 247| (such as :class:`~sklearn.pipeline.Pipeline`). The latter have 248| parameters of the form ``\u0026lt;component\u0026gt;__\u0026lt;parameter\u0026gt;`` so that it\u0026#39;s249|possibletoupdateeachcomponentofanestedobject.250|251|Parameters252|---------- 253| **params : dict 254|Estimatorparameters.255|256|Returns257|------- 258| self : estimator instance 259|Estimatorinstance.後記  延伸閱讀: 在MUR009 思辨註釋與文檔 我們有討論過註釋與文檔的差異. 現在看起來, 可以把「文檔(documentation)」理解為「面向用戶, 對公用方法的解釋」; 而「註釋(comment)理解為「面向開發者, 對私有方法的技術註解」.\n  到此整合了Datacamp課程-Object-Oriented Programming in Python 的邏輯, 結合之前研究經驗, 用物件導向的世界觀來理解線性回歸模組.\n  本文章分了三個面向. 從抽象逐漸具體, 涵蓋心法, 技法, 用法三個層次.\n   第一個面向為「物件導向基礎: 克隆的藍圖」: 扮演心法的角色 第二個面向為「物件導向Python實踐: 狀態, 屬性, 變數; 行為, 方法, 函數.」: 扮演技法的角色 第三個面向為「以物件導向理解線性迴歸模組: type(), dir()與help(): 扮演用法的角色.  感覺寫文章真的是思考最好的方式, 每天不斷的輸出, 讓各種文章寫作過程shape我們的思維. 不斷迭代往前, 逐漸專業, 用自己的宇宙觸碰物理宇宙或元宇宙. 天天向上, 共勉之！  2022.01.13. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-13","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur015%E5%BE%9E%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%80%9D%E8%80%83%E7%B7%9A%E6%80%A7%E8%BF%B4%E6%AD%B8%E5%88%86%E6%9E%90/","series":["每日文章","編程思維"],"tags":["Python"],"title":"MUR015 從物件導向思考線性迴歸分析"},{"categories":[],"content":"從學習2Do軟體反思個人學術工作流  紫式晦澀每日一篇文章第14天\n 前言   今天是2022年第12天, 全年第2週, 一月的第二個週三. 昨日休息後, 今天精力旺盛. 早上思考2Do代辦事項軟體的思維邏輯, 獲得很大的啟發, 今天趕緊寫文章來記錄所思所想.\n  今天的素材主要來自2do的官方文檔 以及個人之前分享的學術工作流. 對於做事的方法, 在今天得到很大的突破！非常棒.\n  重新思考學術工作流: 目標, 計畫, 列表, 任務  學術工作流: 目標, 計畫, 列表, 任務: 從各種職場書籍裡面可以看到各式各樣的管理; 其核心差別其實是看事情的「格局(Scope)」, 也就是要達成的事情的複雜程度. 目前能夠理解到有四個階段: 目標, 計畫, 列表, 任務; 其時間的分佈大概為 3個月, 1個月, 1個禮拜, 1天. 掌握時間的顆粒度顯得十分十分的重要\n  目標, 計畫, 列表, 任務的心法: 感覺還差一步就可以上升到職業發展人生規劃的層次！\n   目標: 從「中期願景」到「短期目標」—\u0026gt;目標管理 計畫: 從「短期目標」到「抽象該做的事」\u0026ndash;\u0026gt; 項目管理 列表: 從「抽象該做的事」到「具體可做的事」—\u0026gt; 任務管理 任務: 從「具體可做的事」到「實際完成的事」—\u0026gt; 精力管理  2Do使用手冊組成邏輯: Meta-work 與Work; 管理列表(Lists)與 管理任務(Tasks)  列表是Meta-Work; 任務是Work: 這個是思維重大突破點; 當我們在安排一天的事情時, 就類似煮菜前的「備料」. 如果把「工作」比喻成「煮菜」, 那麼「元工作」就是「備料」. 當我們把元工作做好, 那實際在工作就可以減少精力磨損. 這個秘笈是「全神貫注」的關鍵.\n  管理列表: 做Pre-Work. 先把「抽象該做的事」切成「具體可做的事」.\n  管理任務: 做Work. 用「精力」完成「具體可做的事」.\n  元工作流(Meta-Workflow): 主要文件, 程式試錯, 知識生產, 每日文章  元工作流(Meta-Workflow): 之前分享學術工作流時, 說到的庫柏學習圈理論的四個階段; 這正好就可以成為「元工作」的四種類型, 藉此驅動「每日工作」; 而「每日工作」在具現化為「列表」, 結構化實際要執行的「任務」.\n  抽象概念化(思考; Abstract Conceptualization): 主要文件; 與「職涯發展」直接相關的, 工作的重要文件. 寫論文, 寫研究報告都屬於這個層次\n  具體經驗(感覺; Concrete Experience): 程式試錯; 任何「論證」類型的工作, 實際自己做一趟, 掃雷可能會卡住的地方, 排除未知的風險。復現他人程序的代碼, 復現他人文章的引理證明, 都屬於這個類型.\n  反思觀察(觀看; Reflective Observation):知識生產; 任何「獲取新知」類型的工作. 學習新的概念, 擴增個人知識庫, 同步最新的科學與技術. 讀文獻, 學課程, 接觸新的mindset, 都屬於這個類型.\n  主動驗證(執行; Active Experimentation):每日文章; 任何「快速輸出」類型的工作. 從心血來潮開始, 把收集到的資訊做「總結」, 「重排」, 「再組織」, 發現資訊後面更深一層的意義. 每日文章, 小總結, 科普文, 談話, 給課程, 都是屬於這個類型.\n  2Do待辦清單軟體細節: 用戶介面, User interface有五個成分: Toolbar, Lists Panel, Tasks list, Utility Panel, Calendar  Toolbar: 創造新的task, 新的project或sub-task; 搜尋; 查看Utility Panel\n  Lists Panel: 三個環節-Focus, Personal, Smart Lists\n  Tasks list: 展現各種輸入的Tasks\n  Utility Panel: 以Tags與Locations來過濾Tasks**\n  Calendar: 展示目前的時間\n  Lists Panel的三個環節: Focus, Personal, Smart Lists  Focus: 有「內建lists」來做filter. 分別有All, Today, Starred, Scheduled, Done.\n  Personal: 塗色以做collection. 可以收集 Tasks, Projects或Checklists.\n  Smart Lists: 一言以蔽之是「搜尋儲存(Saved searches)」. 可使用地點, 動態日期範圍, 固定日期, Tags, 關鍵字等等.\n  五種物件: Lists, List group, Tasks, Projects, Checklists  Lists: 列表是任務, 項目, 核對表的「收集」. 可以被排序, 過濾, 密碼保護, 塗色. A list is a collection of simple tasks, projects and checklists. Lists can be sorted independently, filtered, password protected and colored.\n  List group: 列表群是列表的「收集」. 可以用來組織與重整列表. A list group is a collection of lists. You can create multiple list groups and use them to organize and rearrange your lists.\n  Tasks: 任務是「代辦事項」且可以擁有「1.標題 2.備忘 3.優先級4. 起始日期 5.結束日期6. 語音備忘 7. 圖片. 8. 多重提醒 」. 任務可以「規律重複」. A task represents a to-do item and can have its own title, a note, priority, start and due dates, an embedded audio note, an embedded picture, and multiple alarms. A task can also be set to repeat periodically upon completion based on due date or completion date.\n  Projects: 項目也可以擁有「1.標題 2.備忘 3.優先級4. 起始日期 5.結束日期6. 語音備忘 7. 圖片. 8. 多重提醒 」另外, 項目可以包含「簡單任務」與「子任務」A project has all the properties of a simple task. Additionally, a project can contain other simple tasks as sub-tasks.\n  Checklists: 核對表是「單一執行的項目」: 子任務無法指定「到期/起始日」, 其「到期/起始日」繼承自核對表\n  後記  再見了，20代的資訊與形式之蠱\n歡迎來到30代的結構與價值之魅\n  到此思考整理了2do的官方文檔 以及個人之前分享的學術工作流, 所帶來的工作流思維重大突破.\n  寫作後寫出了「元工作流」這個系統, 非常酷而好用. 這個系統可以是學術工作流的2.0版本, 能夠自驅動任務產生與管理! 天天向上, 共勉之！\n  2022.01.12. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-12","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur014%E5%BE%9E%E5%AD%B8%E7%BF%922do%E8%BB%9F%E9%AB%94%E5%8F%8D%E6%80%9D%E5%80%8B%E4%BA%BA%E5%AD%B8%E8%A1%93%E5%B7%A5%E4%BD%9C%E6%B5%81/","series":["每日文章","學術工作流"],"tags":[],"title":"MUR014 從學習2Do軟體反思個人學術工作流"},{"categories":[],"content":"思考Obsidian外掛templater  紫式晦澀每日一篇文章第13天\n 前言   今天是2022年第11天, 全年第2週, 一月的第二個週二. 今天狀態不好, 臨時day off一天, 讓自己進入發散思維. 研究了Obsidian的外掛templater, 對「範本建立」的技術精進.\n  今天的素材主要來自templator的官方文檔 , 翻譯內文, 閱讀思考的紀錄.\n  簡介Templater  建立範本: 利用Templater可以建立範本, 快速帶入筆記的格式. 很適合執行一些常用的文本分析.\n  使用用戶自訂/內建的變數與函數: 妥善使用內建的變數與函數, 可以讀取很多檔案上的各種性質.\n  使用Eta範本引擎: 這個引擎不太熟悉, 之後有機會研究研究.\n  簡介入門  定義Templater: 一種「範本語言」讓我們能使用變數與函數帶入筆記. 可執行JavaScript代碼來操作這些變數與函數.\n  具體實例:從實例代碼來學習\n   \u0026lt;% tp.file.creation_date() %\u0026gt;: 檔案製造的日期 \u0026lt;% tp.file.last_modified_date(\u0026quot;dddd Do MMMM YYYY HH:mm:ss”): 檔案更新的日期 [[\u0026lt;% tp.date.now(\u0026quot;YYYY-MM-DD\u0026quot;, -1) %\u0026gt;]]: 現在前一天 [[\u0026lt;% tp.date.now(\u0026quot;YYYY-MM-DD\u0026quot;, 1) %\u0026gt;]]: 現在後一天 \u0026lt;% tp.file.title %\u0026gt;: 檔案的名字  術語入門  模板: 包含命令的檔案: A template is a file that contains commands.\n  命令: 被\u0026lt;% %\u0026gt;給包裝的變數與函數: A text snippet that starts with an opening tag \u0026lt;%, ends with a closing tag %\u0026gt; and that contains some variable / function is what we will call a command.\n  變數與函數: 可使用「命令」的物件, 能回傳「值」. 分別有「內建變數與函數」和「用戶定義函數」\n  內建變數與函數: 包已經定義好的變數與函數: They are predefined variables / functions that are built within the plugin. As an example, tp.file.title is an internal variable that will return the name of the file.\n  用戶定義函數: 看創意: Users can define their own functions in the plugin settings. They are either system command user functions or script user functions.\n  內建模組 內建模組: 有七種內建模組(Internal modules)   Config module: tp.config Date module: tp.date File module: tp.file Frontmatter module: tp.frontmatter Obsidian module: tp.obsidian System module: tp.system Web module: tp.web  學習object hierarchy: tp是一個物件. 命令的公式為\u0026lt;% tp.\u0026lt;module_name\u0026gt;.\u0026lt;internal_variable_or_function_name\u0026gt; %\u0026gt;  Config Module Config Module : 裡面的東西感覺暫時都用不到  Date Module Date Module : 昨天, 今天, 明天  File Module File Module : 創造檔案相關的東西, 感覺蠻有用的   tp.file.creation_date(format: string = \u0026quot;YYYY-MM-DD HH:mm\u0026quot;): Retrieves the file\u0026rsquo;s creation date. tp.file.last_modified_date(format: string = \u0026quot;YYYY-MM-DD HH:mm\u0026quot;) : Retrieves the file\u0026rsquo;s last modification date. tp.file.title: Retrieves the file\u0026rsquo;s title. tp.file.tags: Retrieves the file\u0026rsquo;s tags (array of string, comma separated)  Frontmatter Module Frontmatter Module : 可以抽取note的meta data! 所以很融通！   tp.frontmatter.\u0026lt;frontmatter_variable_name\u0026gt;: Retrieves the file\u0026rsquo;s frontmatter variable value.  1\u0026lt;% tp.frontmatter[\u0026#34;variable name with spaces\u0026#34;] %\u0026gt; 2 3--- 4alias: myfile 5note type: seedling 6--- 7 8file content 9 10File\u0026#39;s metadata alias: \u0026lt;% tp.frontmatter.alias %\u0026gt; 11Note\u0026#39;s type: \u0026lt;% tp.frontmatter[\u0026#34;note type\u0026#34;] %\u0026gt; Obsidian Module Obsidian Module : 沒有具體例子, 要回到Obsidian的API. 之後再研究如何使用.  System Module System Module : 這個用法要之後研究, 還沒經驗.  Web Module Web module : 主要用來抓隨機圖片當筆記每日封面   tp.web.random_picture(size?: string, query?: string): Gets a random image from https://unsplash.com/   後記  到此翻譯思考了templator的官方文檔 . 看來還是需要實踐才會有更具體的感覺. 這個之後來補.\n  希望之後能讓紀錄資訊的效率更高！時時編輯寫作, 時時傳達思想！共勉之!\n  2022.01.11. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-11","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur013%E6%80%9D%E8%80%83obsidian%E5%A4%96%E6%8E%9Btemplater/","series":["每日文章"],"tags":["Obsidian"],"title":"MUR013 思考Obsidian外掛templater"},{"categories":["合成數據","可信任的AI"],"content":"合成數據於Chase銀行的金融應用  紫式晦澀每日一篇文章第12天\n 前言   今天是2022年第10天, 全年第2週, 一月的第二個週一. 今天來累積金融應用的各種術語知識.\n  今天的素材主要來自Chase銀行的技術部落格 Synthetic Data for Real Insights 中, 翻譯內文, 閱讀思考的紀錄.\n  合成數據: 作為大數據時代隱私保護解決方案  合成數據的背景: J.P. Morgan AI Research 生成合成數據集，以加速金融服務領域的研究和模型開發。要使 AI 模型有效地展示業務場景中的人類行為，它們需要接受大量代表現實的數據的訓練。 金融服務行業會產生大量可能非常有益的數據，但這些數據通常無法使用。 這對研究人員和開發人員提出了根本性挑戰。\n  真實數據的限制: 真實數據在許多方面可能難以訪問，包括隱私、法律許可以及與數量、表示和含義相關的技術方面。\n   如何實現依賴數據的新產品和服務的創新和構建?\n一個答案是使用合成數據!\n  合成數據優點一: 替代真實數據, 但共享格式與分佈: 可以與真實數據共享格式、分佈和標準化內容，同時不會產生使用真實數據的風險。\n  合成數據優點二: 增加AI算法穩健性, 因可探索歷史數據外的場景:合成數據可能具有額外的好處，即代表歷史數據之外的探索性場景，以準備 AI 算法並支持在新情況下的決策。 因此，合成數據使我們能夠更加穩健地應對具有挑戰性的情況。\n  合成數據優點三: 增加罕見示例, 更有效訓練ML算法:合成數據可以增加真實數據中可能很少見的示例，以便更有效地訓練機器學習算法。\n  合成數據優點四: 生成測試場景, 快速驗證新想法效果:最終，如果一個新想法在合成數據上顯示出前景，我們可以考慮將其推進實際部署並在真實數據上使用。\n  訓練方法: 真實數據的「生成模式建模」或「深度神經網路學習」  不同數據類型, 不同合成方法: 通過研究，摩根大通的人工智能研究團隊確定了幾種創建合成數據的方法，並了解到不同的方法可能適用於不同類型的數據。\n  方法一: 真實數據生成模式建模(Generative Modeling): 我們可以通過了解生成真實數據的過程來創建真實的合成數據，然後對過程本身進行建模以生成合成數據。該模型可以是聲明性(declarative)的或在模擬中捕獲(captured in simulations)。\n  方法二: 真實數據深度神經網路學習: 直接使用真實數據來訓練生成神經網絡（GNN），它已成功用於生成各種其他合成數據。\n  場景洞察: 詐欺檢測, 異常偵測, 反洗錢, 客戶旅程, 市場執行  合成數據提供新洞察: 合成的新樣本具有真實數據的屬性，但無法映射回真實數據。新樣本提供了對可能未被發現的數據的洞察。\n  關鍵場景一:欺詐檢測(fraud detection)模型訓練:\n   合成數據為 AI 模型提供了正常(normal transactions)和欺詐交易(fraudulent transactions)的示例，以了解可疑交易模式(suspicious transaction patterns)。 由於與非欺詐案件相比，欺詐案件的數量非常少，因此建模方法難以從可用數據中有效地訓練關於欺詐行為的模型。  關鍵場景二:異常行為(anomalous behavior)模型訓練:   成數據可用於訓練異常行為(anomalous behavior)模型。 該過程使不符合預期行為的交易比例更高，從而生成更多欺詐案例的合成樣本，以改進模型訓練。   關鍵場景三:反洗錢 (Anti0money laundering) 行為\n  關鍵場景四:客戶旅程(Customer journey)事件\n  關鍵場景五:市場執行(Markets execution)數據\n  關鍵場景六:用於欺詐檢測的支付數據(Payments data)\n  研究社群: 用戶公司互動模擬, 強監管產業的新研究範式  合成數據: 本質上模擬用戶與公司的互動: 該公司人工智能研究主管 Manuela Veloso 回顧了該團隊在零售銀行業務中啟用的合成數據功能。 “例如，合成數據生成讓我們能夠思考客戶開戶和申請貸款的整個生命週期。我們不只是檢查數據以了解人們在做什麼，而且我們還能夠分析他們與公司的互動，並從本質上模擬整個過程。”\n  合成數據的工作延伸: 該團隊的合成數據工作已經發展。自 2 月份提供其合成數據集以來，該團隊已經收到了許多對這些功能的請求。此外，該公司在斯坦福大學、康奈爾大學、CMU、布法羅大學、紐約大學和其他大學的教師研究獲獎者 正在利用數據集開發算法，以解決欺詐和洗錢、客戶旅程、市場執行和金融領域的其他領域。\n  合成數據: 強監管產業的新研究範式:AI Research 執行董事 Rob Tillman 總結了其合成數據所面臨的挑戰及其優勢。 “在金融等處理敏感數據的高度監管行業中，通常存在重大障礙，阻礙或延遲研究人員和開發人員使用數據開發人工智能解決方案以改善體驗或解決欺詐檢測和反欺詐等重要問題的能力。洗錢。該團隊的合成數據工作旨在解決這個問題，加速摩根大通人工智能解決方案的開發，並促進與學術界的合作。”\n  後記  到此翻譯思考了Synthetic Data for Real Insights 大部分的內容. 首先合成數據作為大數據時代隱私保護解決方案, 希望能替代真實數據的使用, 成為新時代的可再生能源. 訓練方法上, 可以執行「生成模式建模」或「深度神經網路學習」. 使用的場景主要是詐欺偵測與異常偵測. 對於金融業界而言, 合成數據能夠模擬用戶與公司的互動, 有望成為強監管產業的新研究範式.\n  閱讀翻譯過這篇文章以後, 感覺AI for Finance是一個很好研究AI知識如何落地的很好的場景. 聯想到今天聽到的元宇宙是AI科技落地的一大場景, 感覺五年十年會有許多新的商業模式可以出來. 非常有趣.\n  每天加強自己的coding能力, 將思維從科學轉為工程, 是解決自己時代問題的負責任的態度！主動實踐, 創造個人經驗, 推動時代, 共勉之！\n  2022.01.10. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-10","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur012%E5%90%88%E6%88%90%E6%95%B8%E6%93%9A%E6%96%BCchase%E7%9A%84%E9%87%91%E8%9E%8D%E6%87%89%E7%94%A8/","series":["每日文章"],"tags":["金融科技"],"title":"MUR012 合成數據於Chase銀行的金融應用"},{"categories":["educative 課程"],"content":"思考Bash中的Globbing與Quoting  紫式晦澀每日一篇文章第11天\n 前言   今天是2022年第9天, 全年第2週, 一月的第二個週日. 今天來組織educative課程裡面關於Bash相關的知識.\n  今天的素材主要來自educative 課程-Master the Bash Shell-Core Bash 中, 節選相關段落與紀錄個人理解與心得.\n  Bash是shell程序 Bash是shell程序: shell 程序通常是一個「可執行二進製文件」. 它接受鍵入的命令，並且（一旦按return）將這些命令轉換為（最終）對操作系統 API 的系統調用。 (二進制: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).)   Shell程序: 告訴電腦做什麼. 把不同的程序glue在一起.\n  其他的shell程序: 市面上還有其他的shell程序, 包含sh, ash, dash, ksh, tcsh, zsh, tclsh. 只有看過sh.\n  Bash的歷史: Bash原名 ‘Bourne Again SHell’. 是‘Thompson Shell’ 的後代. 其兄弟有‘siblings’ (eg, ksh), ‘cousins’ (eg, tcsh), and ‘children’, (eg, zsh).\n  Globbing與Quoting  *指令的意思: shell轉換*轉換, 配對到「current working directory的所有檔案」.\n  正規表達式:正規表達式是用來matching字串的模式. 與globbing達到的matching檔案不一樣.\n  glob: 在電腦編程中, glob模式指定一組帶著通配符的檔案名字 In computer programming, glob patterns specify sets of filenames with wildcard characters.\n  例子: 看所有在工作目錄中的檔案:\n     製造三個檔案file1, file2, file3.    用ls看存在的檔案, match *    用echo印出檔案, match *.    1touch file1 file2 file3 2ls * 3echo *  Quoting:用單引號「*」與雙引號「*」會改變bash讀取內容的方式. 在變數環節會學到更多.\n  Globbing primitive:\n   * - matches files in current working directory 工作目錄的檔案 ? - matches any single character 單字元 [abd] - matches any character from a, b or d 特定字元 [a-d] - matches any character from a, b, c or d 範圍內字元  實例: 配對檔案 找有1的, 有file數字的  1root@educative:~/glob# ls *1 2file1 3root@educative:~/glob# ls file[a-z] 4ls: cannot access \u0026#39;file[a-z]\u0026#39;: No such file or directory 5root@educative:~/glob# ls file[0-9] 6file1 file2 file3 7root@educative:~/glob# ls file? 8file1 file2 file3 Dotfiles: 造了也在ls, ls*看不到的檔案們. 這樣這些檔案不會被簡單改動  1root@educative:~/glob# touch .adotfile 2root@educative:~/glob# mkdir .adotfolder 3root@educative:~/glob# touch .adotfolder/file1 .adotfolder/.adotfile 4root@educative:~/glob# ls 5file1 file2 file3  單點.表示目前檔案夾: single dot folder . 表達目前在的檔案夾. cd . 就會在原地不動\n  雙點..表示雙親檔案夾: double dot folder .. 表達雙親檔案夾. cd ..會到上一層.\n  後記  到此學習了educative 課程-Master the Bash Shell-Core Bash 中前兩節的內容. 首先了解Bash是一種Shell 程序, 主要讓我們能與把不同的program一起合作. 接下來看了globbing, 關於*表達「目前工作目錄的所有檔案」有了基礎認識; 接著quoting則提到單引號雙引號, 會有不同的效果. 可惜還沒精力讀到variable的章節, 之後再來思考quoting的深刻用法.\n  今天看了很不熟的主題-Bash編程, 知道的很少, 所以得慢慢前進. 接下來一年要主力投資工程技能, 增加工程能力去做更寬廣的研究. 實踐數學, 用最新科技, 創造新價值, 推動時代. 天天向上, 共勉之！\n  2022.01.09. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-09","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur011%E6%A0%B8%E5%BF%83bash%E7%9F%A5%E8%AD%98/","series":["每日文章"],"tags":["Bash"],"title":"MUR011 思考Bash中的Globbing與Quoting"},{"categories":[],"content":"全新思維裡的三感三力  紫式晦澀每日一篇文章第10天\n  前言   今天是2022年第8天, 全年第2週, 一月的第二個週六. 今天在得到聽書聽到有趣的「全新思維」, 其中強調左腦思維的任務很多在被人工智慧給自動化,而未來的人會有更多的時間使用「右腦思維」才能達到的境界. 十分有意思, 也關係到我們平時如何分配自己的精力, 因此寫文章記錄所想所感.\n  今天的素材主要來自得到聽書-全新思維:決勝未來的六大因素 中, 節選相關段落與紀錄個人理解與心得.\n  三感: 設計感, 娛樂感, 意義感  設計感: 設計是一種能力, 要求我們有很高的審美標準, 去不斷地追求新穎和美感. 人們不會為物品買單, 而是為設計買單. 審美就是靠直覺體曲優化信息的能力, 也是人類無法被機器取代的能力. 要對美有所感悟, 才能脫離價格戰, 往更高的領域跑.\n  找到設計感: 多看, 用相機紀錄生活中覺得醜的東西, 想想醜的原因; 紀錄很美的東西, 把美的原因寫下來, 哪個元素吸引到你. 多參觀創憶博物館, 多讀設計雜誌, 多觀察生活. 美, 需要不斷地接近與陶冶.\n  娛樂感: 把娛樂像基因浸入你的血液中. 浸入一個文化中, 產生娛樂感. 「好玩」在現在已經是一個非常重要的核心競爭力.\n  找到娛樂感: 我覺得學習各種文化, 思考存在的各種事物背後的文化背景, 就可以與該文化的人互動產生共鳴.\n  意義感: 也就是自我實現. 你做的事情被不被別人需要, 有沒有價值, 你能不能把你做的事和一個偉大的東西聯繫 到一塊? 在末來, 意義感會變得更為重要, 所有有才能的人都會追求自我實現, 要追求自我價值的最 大化.\n  找到意義感: 學會把自己做的事嫁接到一個很偉大的目標上. 例如. 現在做研究工作, 會帶來知識, 讓我能快速學習, 有很大的自由度, 做創造性的動作. \u0026gt; 意義是自己找的, 需要自己賦予.\n  三力: 故事力, 交想力, 共情力  故事力: 在敘事中加入情緒, 吸引讀者. 用故事調動人的情緒.\n  鍛鍊故事力: 寫迷你小說. 寫一個100字左右的超短小說. 在100字表達人物, 關係, 鋪墊, 轉折四點, 練習編故事的能力.\n  交想力: 系統思維, 把看似無關的因素組合的能力. 右腦思考的特點, 注重大局, 不糾纏細節, 成為跨領域打劫的人才.\n  鍛鍊交想力: 思考「跨界思維」. 練習比喻, 把理解事物的層次昇華. 了解新事物, 利用比喻來轉化為熟悉的東西.\n  共情力: 要與別人產生共鳴. 右腦思維是體會對方的情緒, 然後引導. 共感對方的情緒, 接著轉到你想要導向的方向過去.\n  鍛鍊共情力: 練習去體會別人的情緒, 站在對方的角度想問題, 去感知別人, 和對方達到一個情緒和思想頻率, 是在未來與理智思考相當重要的能力.\n  後記  到此紀錄了得到聽書-全新思維:決勝未來的六大因素 中提到在未來使用「右腦思維」所需要的三感三力.\n  從設計感娛樂感意義感, 來看vtuber產業, 需要「皮」設計得好, 「中之人」要懂聽眾文化帶來娛樂, 而「意義感」則是在為未來元宇宙的世界積累實力. 我想vtuber在未來會是一個很有競爭力的履歷.\n  從故事力交想力共情力, 來看教育產業, 我想未來我們在講知識點要帶出「故事脈絡」才能使資訊昇華為解決具體問題的知識; 而「串連新與舊」來讓學生的舊經驗得到新體會, 加深學習效果; 而「共情力」則是去了解學生發生的困難點具體在哪邊, 與其共感後提供教練式領導, 引學生到想要的方向.\n  很棒的週六早上! 今天是每日一篇文章的第10天! 今天是一個思維的文章, 短短的, 但對許多mindset有額外的角度, 來思考自己的價值與時間精力分佈的方向. 讓每一個精神上的邂逅留下紀錄, 積極前進, 共勉之！\n  2022.01.08. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-08","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur010%E5%85%A8%E6%96%B0%E6%80%9D%E7%B6%AD%E8%A3%A1%E7%9A%84%E4%B8%89%E6%84%9F%E4%B8%89%E5%8A%9B/","series":["每日文章"],"tags":["得到聽書"],"title":"MUR010 全新思維裡的三感三力"},{"categories":["物件導向編程"],"content":"思辨註釋與文檔  紫式晦澀每日一篇文章第9天\n  前言   今天是2022年第7天, 第1週的第1個週五. 今天來思考紀錄, 在寫程式時很重要的, 關於「註解與文檔」相關的知識. 長期而言, 這是「編程思維」系列下的第一篇.\n  今天的素材主要來自Documenting Python Code: A Complete Guide 中, 節選相關段落與紀錄個人理解與心得.\n  註解與文檔: 為讀者服務 讀者思維於程式: 寫程式本身為兩種主要讀者服務. 第一種是開發者(包含未來的自己), 另一種是使用者. 作為開發者, 把註解(Comment)寫好, 也會讓未來的自己省時間. 作為使用者, 把文檔(Documentation)寫好, 會讓未來可能的使用者學習成本下降.   “Code is more often read than written.”\n— Guido van Rossum\n 定義註解: 「程式註解」是向開發者描述你的程式. 預期的主要受眾是 Python 程式的維護者和開發者。 編寫良好的程式+註釋有助於引導讀者更好地理解你的程式的「目的」和「設計」.   “Code tells you how; Comments tell you why.”\n— Jeff Atwood (aka Coding Horror)\n 定義文檔: 「程式文檔」是向使用者描述你的程式的用途與功能. 其主要的受眾為用戶, 也會在開發過程中有幫助.  註解: 面向開發者 註解的兩種技法: 井字號, 類型提示 利用#給註解: 註解應該是「簡潔的幾個句子」. 例如:  1def hello_world(): 2 # A simple comment preceding a simple print statement 3 print(\u0026#34;Hello World\u0026#34;) 其中的「# A simple comment preceding a simple print statement」就是簡潔的註解. 根據PEP 8 , 一個註解不超過72個字元.\n利用類型提示: 類型提示(Type Hint)於 Python 3.5 開始支援.類型提示是一種幫助讀者閱讀程式的附加形式。它允許開發人員設計和解釋他們的部分代碼而不用註釋。 例如  1def hello_name(name: str) -\u0026gt; str: 2 return(f\u0026#34;Hello {name}\u0026#34;) 就提示了函數hellp_name是一個輸入為字串str資料類型, 輸出也是字串str資料類型的函數.\n通過檢查類型提示，可以立即看出該函數期望輸入名稱為 str 或字符串類型。 此外, 還可以判斷該函數的預期輸出也將是 str 或 string 類型。 雖然類型提示有助於減少註釋，但在創建或更新項目文檔時，這樣做也可能會增加額外的工作量。   省現在的時間, 或省未來的時間.\n 註解的四種用法: 計畫與回顧, 程式描述, 演算法描述, 標記待改良點 註解用法一:計畫與回顧: 當開發程式的新部分，可以首先使用註釋作為「規劃(Planning)」或概述該部分程式。 一旦實際程式已經實踐和審查/測試，就可以刪除這些註解.  1# First step 2# Second step 3# Third step  這個用法, 在寫文章也很常用. 尤其是寫科學研究論文的草稿時, 用註解的方式先安排文章的結構, 然後分個完成. 完成後的部分, 之後重新組合, 可能可以出現更好的組織, 昇華文章帶給讀者的意象.\n  註解用法二:程式描述: 註解可解釋「特定部分程式」的意圖.\n  1# Attempt a connection based on previous settings. If unsuccessful, 2# prompt user for new settings.  這個用法, 在寫理論文章時, 因為要證明很多lemma, 也會利用註解來描述特定lemma的意圖. 因此, 我們可以很合理的類比「lemma」就是「script」 , 而很多的lemma與很多的script構造出智慧的結晶.\n  註解用法三:演算法描述: 複雜的演算法, 可以利用註解向開發者解釋如何實踐你的程式. 也可描述為何選擇特定的算法. 這個可以寫在function裡面詳細每步的動機.\n  1# Using quick sort for performance gains 註解用法四: 標記: 對特定部分的程式, 標記已知問題, 來改良該部分的問題. 實際例子有: BUG, FIXME 與 TODO.  1# TODO: Add condition for when val is None Jeff Atwood的四條註解規則: 就近註釋, 避免複雜格式, 開門見山, 設計好的程式結構  就近註釋原則: 使註釋盡可能靠近所描述的代碼。 不在描述代碼附近的註釋會讓讀者感到沮喪，並且在進行更新時很容易錯過。\n  避免複雜格式: 不要使用複雜的格式（例如表格或 ASCII 數字）。 複雜的格式會導致內容分散注意力，並且隨著時間的推移可能難以維護。\n  開門見山原則: 不要包含多餘的信息。 假設代碼的讀者對編程原理和語言語法有基本的了解。\n  設計好的程式結構: 設計你的代碼來評論自己。 理解代碼最簡單的方法是閱讀它。 當您使用清晰、易於理解的概念設計代碼時，讀者將能夠快速概念化您的意圖。\n  文檔: 面向使用者 用字符串做文檔: 前面了解了註釋(Comment), 現在開始討論文檔(Documentation). 我們要學習使用「字符串 (Docstrings)」來做文檔. 若內置的字符串配置正確, 可顯著幫助用戶與自己的項目發展.  召喚字符串, 物件目錄, 文檔: help(), dir(), __doc__ help()召喚字符串: 利用Python的內置函數help()可召喚出「物件字符串」. 例如:  1\u0026gt;\u0026gt;\u0026gt; help(str) 2Help on class str in module builtins: 3 4class str(object) 5 | str(object=\u0026#39;\u0026#39;) -\u0026gt; str 6 | str(bytes_or_buffer[, encoding[, errors]]) -\u0026gt; str 7 | 8 | Create a new string object from the given object. If encoding or 9 | errors are specified, then the object must expose a data buffer 10 | that will be decoded using the given encoding and error handler. 11 | Otherwise, returns the result of object.__str__() (if defined) 12 | or repr(object). 13 | encoding defaults to sys.getdefaultencoding(). 14 | errors defaults to \u0026#39;strict\u0026#39;. 15 # Truncated for readability dir()召喚物件目錄: 在Python中, 什麼都是物件(Object). 利用函數dir()可召喚出物件的目錄(directory).  1\u0026gt;\u0026gt;\u0026gt; dir(str) 2[\u0026#39;__add__\u0026#39;, ..., \u0026#39;__doc__\u0026#39;, ..., \u0026#39;zfill\u0026#39;] # Truncated for readability 目錄的屬性:__doc__: 在召喚出來的物件目錄中, 有個特殊的屬性__doc__, 其內容如下:  1\u0026gt;\u0026gt;\u0026gt; print(str.__doc__) 2str(object=\u0026#39;\u0026#39;) -\u0026gt; str 3str(bytes_or_buffer[, encoding[, errors]]) -\u0026gt; str 4 5Create a new string object from the given object. If encoding or 6errors are specified, then the object must expose a data buffer 7that will be decoded using the given encoding and error handler. 8Otherwise, returns the result of object.__str__() (if defined) 9or repr(object). 10encoding defaults to sys.getdefaultencoding(). 11errors defaults to \u0026#39;strict\u0026#39;. 文檔客製物件:編輯__doc__, 三引號(triple-double quote)註解, 多行字符串 客製物件的文檔1: 編輯__doc__: 自定義函數, 可以透過編輯其__doc__屬性來提供文檔.  1def say_hello(name): 2 print(f\u0026#34;Hello {name}, is it me you\u0026#39;re looking for?\u0026#34;) 3 4say_hello.__doc__ = \u0026#34;A simple function that says hello... Richie style\u0026#34; 1\u0026gt;\u0026gt;\u0026gt; help(say_hello) 2Help on function say_hello in module __main__: 3 4say_hello(name) 5 A simple function that says hello... Richie style 客製物件的文檔2:三引號(triple-double quote)註解:另一種方法來寫函數的文檔, 是直接在def的下面加註解.  1def say_hello(name): 2 \u0026#34;\u0026#34;\u0026#34;A simple function that says hello... Richie style\u0026#34;\u0026#34;\u0026#34; 3 print(f\u0026#34;Hello {name}, is it me you\u0026#39;re looking for?\u0026#34;) 1\u0026gt;\u0026gt;\u0026gt; help(say_hello) 2Help on function say_hello in module __main__: 3 4say_hello(name) 5 A simple function that says hello... Richie style 多行字符串的格式: 當文檔較為精緻, 成為多行字符串, 則建議包含以下四個部分:   A one-line summary line 一行總結 A blank line proceeding the summary 一行空白 Any further elaboration for the docstring 更細緻的描述 Another blank line 另一行空白  三大文檔類型: 類字符串, 包與模組字符串, 腳本字符串 定義三大文檔類型:   Class Docstrings: 類(Class) and 類方法(class methods) Package and Module Docstrings: 包(Package), 模組(modules), and 函數(functions) Script Docstrings: 腳本(Script) and 函數(functions)  類字符串: __init__類方法上 類與類方法字符串: 定義類與類方法以後, 建議就加上文檔.  1class SimpleClass: 2 \u0026#34;\u0026#34;\u0026#34;Class docstrings go here.\u0026#34;\u0026#34;\u0026#34; 3 4 def say_hello(self, name: str): 5 \u0026#34;\u0026#34;\u0026#34;Class method docstrings go here.\u0026#34;\u0026#34;\u0026#34; 6 7 print(f\u0026#39;Hello {name}\u0026#39;) 其中有SimpleClass這個類的文檔, 也有say_hello這個類方法的文檔.\n類文檔應有資訊:類文檔應有以下四種資訊     A brief summary of its purpose and behavior 簡述類的「目的」與「行為」    Any public methods, along with a brief description 任何「公用方法」與其簡單描述    Any class properties (attributes) 任何「類屬性」    Anything related to the interface for subclassers, if the class is intended to be subclassed 是否是作為「介面(interface)」而建立的類     __init__類方法文檔: 在__init__類方法的字符串, 應該要聞黨類創造子的參數(class constructor parameters). 類創造子是一個物件導向中的基礎概念, 其限定了類創造物件時的細節.\n  類方法字符串應有資訊: 類方法字符串應有資訊包含以下六點:\n     A brief description of what the method is and what it’s used for 方法的簡單描述與其目的    Any arguments (both required and optional) that are passed including keyword arguments 任何會在「關鍵字參數 (Keyword arguments)」中「必要(required)」或「可選(optional)」的「實際參數(argument)」    Label any arguments that are considered optional or have a default value 標記可選參數或其預設值    Any side effects that occur when executing the method 方法的副作用    Any exceptions that are raised 會出現的例外    Any restrictions on when the method can be called 呼叫方法後會引發的限制    實例: Animal類: 這個類有簡單的「類屬性(class properties)」, 「實例屬性(instance properties)」, 「__init__類方法」, 「實例方法(instance method )」  1class Animal: 2 \u0026#34;\u0026#34;\u0026#34; 3A class used to represent an Animal 45... 67Attributes 8---------- 9says_str : str 10a formatted string to print out what the animal says 11name : str 12the name of the animal 13sound : str 14the sound that the animal makes 15num_legs : int 16the number of legs the animal has (default 4) 1718Methods 19------- 20says(sound=None) 21Prints the animals name and what sound it makes 22\u0026#34;\u0026#34;\u0026#34; 23 24 says_str = \u0026#34;A {name}says {sound}\u0026#34; 25 26 def __init__(self, name, sound, num_legs=4): 27 \u0026#34;\u0026#34;\u0026#34; 28Parameters 29---------- 30name : str 31The name of the animal 32sound : str 33The sound the animal makes 34num_legs : int, optional 35The number of legs the animal (default is 4) 36\u0026#34;\u0026#34;\u0026#34; 37 38 self.name = name 39 self.sound = sound 40 self.num_legs = num_legs 41 42 def says(self, sound=None): 43 \u0026#34;\u0026#34;\u0026#34;Prints what the animals name is and what sound it makes. 4445If the argument `sound` isn\u0026#39;t passed in, the default Animal 46sound is used. 4748Parameters 49---------- 50sound : str, optional 51The sound the animal makes (default is None) 5253Raises 54------ 55NotImplementedError 56If no sound is set for the animal or passed in as a 57parameter. 58\u0026#34;\u0026#34;\u0026#34; 59 60 if self.sound is None and sound is None: 61 raise NotImplementedError(\u0026#34;Silent Animals are not supported!\u0026#34;) 62 63 out_sound = self.sound if sound is None else sound 64 print(self.says_str.format(name=self.name, sound=out_sound)) 包與模組字符串: __init__.py檔案中  包字符串: 包字符串要在包頂層的__init__.py檔案中. 這個字符串要包含「模組(modules)」與「子包(subpackages)」的列表.\n  模組字符串: 模組字符串要列表出任何其包含的函數. 模組字符串要在整的文件的最頂端. 須包含以下兩點:\n     A brief description of the module and its purpose 簡述模組與其目的    A list of any classes, exception, functions, and any other objects exported by the module 列表類, 例外, 函數, 其他任何模組會輸出的物件.    模組函數文檔: 其規則與「類方法」類似, 要包含六點:     A brief description of what the method is and what it’s used for 方法的簡單描述與其目的    Any arguments (both required and optional) that are passed including keyword arguments 任何會在「關鍵字參數 (Keyword arguments)」中「必要(required)」或「可選(optional)」的「實際參數(argument)」    Label any arguments that are considered optional or have a default value 標記可選參數或其預設值    Any side effects that occur when executing the method 方法的副作用    Any exceptions that are raised 會出現的例外    Any restrictions on when the method can be called 呼叫方法後會引發的限制    腳本字符串: argparse活用  定義腳本: 腳本(Scripts)是主機(Console)可執行的單檔案. Scripts are considered to be single file executables run from the console.\n  腳本字符串: 要在檔案最上方, 要提供足夠資訊讓用戶能使用腳本.\n  使用argparse:使用argparser.parser.add_argument函數, 利用argpase的__doc__文檔來對參數的description. (詳細請見Command-Line Parsing Libraries )\n  列出腳本前置包: 文檔要包含讓用戶知道要先安裝哪些包. 以下是列印表格欄的腳本. 有說明要安裝pandas還有要輸入模組get_spreadsheet_cols，並包含函數main.\n  1\u0026#34;\u0026#34;\u0026#34;Spreadsheet Column Printer 23This script allows the user to print to the console all columns in the 4spreadsheet. It is assumed that the first row of the spreadsheet is the 5location of the columns. 67This tool accepts comma separated value files (.csv) as well as excel 8(.xls, .xlsx) files. 910This script requires that `pandas` be installed within the Python 11environment you are running this script in. 1213This file can also be imported as a module and contains the following 14functions: 1516* get_spreadsheet_cols - returns the column headers of the file 17* main - the main function of the script 18\u0026#34;\u0026#34;\u0026#34; 19 20import argparse 21 22import pandas as pd 23 24 25def get_spreadsheet_cols(file_loc, print_cols=False): 26 \u0026#34;\u0026#34;\u0026#34;Gets and prints the spreadsheet\u0026#39;s header columns 2728Parameters 29---------- 30file_loc : str 31The file location of the spreadsheet 32print_cols : bool, optional 33A flag used to print the columns to the console (default is 34False) 3536Returns 37------- 38list 39a list of strings used that are the header columns 40\u0026#34;\u0026#34;\u0026#34; 41 42 file_data = pd.read_excel(file_loc) 43 col_headers = list(file_data.columns.values) 44 45 if print_cols: 46 print(\u0026#34;\\n\u0026#34;.join(col_headers)) 47 48 return col_headers 49 50 51def main(): 52 parser = argparse.ArgumentParser(description=__doc__) 53 parser.add_argument( 54 \u0026#39;input_file\u0026#39;, 55 type=str, 56 help=\u0026#34;The spreadsheet file to pring the columns of\u0026#34; 57 ) 58 args = parser.parse_args() 59 get_spreadsheet_cols(args.input_file, print_cols=True) 60 61 62if __name__ == \u0026#34;__main__\u0026#34;: 63 main() 後記 發展文檔: 原文後面有個文檔進展的五個階段:     No Documentation    Some Documentation    Complete Documentation    Good Documentation    Great Documentation 感覺這也很適合講正在執筆寫的論文. 從No, some, complete, good, great. 先搞出完整的, 再到好, 再到很棒. 用這樣子來分類項目的成熟度, 十分不錯.     到此紀錄了由Documenting Python Code: A Complete Guide 中, 節選的相關段落. 首先理解註解是為開發者而服務, 而文檔是為用戶而服務. 接著看了類與類方法, 包與模組, 腳本三種Python文件的文檔字符串寫法.\n  非常好！今天是每日一篇文章的第九天. 今天這個技術文章很長, 一段一段讀, 改寫, 也刺激自己對這些技術概念的融會貫通, 感覺心中更踏實. 持續輸出! 共勉之！\n  2022.01.07. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-07","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur009%E8%A9%95%E8%AB%96%E8%88%87%E6%96%87%E6%AA%94/","series":["每日文章","編程思維"],"tags":["Python"],"title":"MUR009 思辨註釋與文檔"},{"categories":["寫作","得到課程"],"content":"讀蔡鈺商業參考發刊詞-理解商業, 與世界保持同步  紫式晦澀每日一篇文章第8天\n  前言   今天是2022年第6天, 第1週的第1個週四. 今天早上聽到蔡鈺老師的商業參考發刊詞-理解商業, 與世界保持同步, 對思維影響巨大！決定趁著興致把所思所想組織成文章, 以更深入看見這段邂逅的價值.\n  今天的素材主要是從蔡鈺老師的商業參考得到課程:发刊词: 理解商业, 与世界保持同步 的閱讀中, 紀錄組織下來的個人所思所想.\n  智慧: 深思熟慮, 抑或見多識廣? 見多識廣, 或者深思熟慮?: 這句話真是打中我心. 兩者的偏好, 我也慢慢從後者轉移到前者. 但這不代表不再深思熟慮, 而是用已經習慣的深度, 敏捷地去見更多的世面, 認識更廣的現象.   在开始为期一年的唠嗢之前, 我想先问你一个问题: 同样是形容有智慧, 有两个词, 见多识广和深思熟虑, 如果要你来选, 你更向往哪种状态? 当然这俩不是冲突的, 我问的是偏好。\n  爱德华. 德博诺, 《六顶思考帽》的作者, 说过一段话。他说: 思考的目的不是要做到正确,而是要做到有效。正确的意思是你从头到尾都要正确, 而有效呢, 只要求最终正确就可以。\n 思考的目的不是要做到正确, 而是要做到有效。 一爱德华 - 德博诺\n   深思熟慮求穩定: 如果想要时刻保持正确, 就很容易求稳, 会放弃寻找新思路\n  求新求變, 而不是在一個地方持續replay, 我的天性似乎更喜歡變來變去. 畢竟, 李李玲蘭, Gura, Laplus都是搞怪的代表, 而也很符合我認為的「有趣」.\n  見多識廣求有效: 但如果想要做到的是有效, 那么我们途中就应该让想法足够多, 即使中间有些想法是错的也没关系, 这总比满足于已有的正确答案, 放弃新想法要强。有一句话叫做「朝一个方向看得再远, 你也末必能看到新方向」, 也是这个意思。所以, 见多识广 当然不是反对正确, 只不过它追求的不是正确, 而是丰富。\n  或許, 年紀大的時候寫書, 會講求的是「系統化的豐富」, 來提供下一代人進入這些人類智慧結晶的知識地圖. 有意思.\n  解釋: 不一定是唯一正確的答案, 但提供豐富觀察維度, 與視野的開闊程度  解釋不一定是唯一正確的答案, 但提供豐富觀察維度, 與視野的開闊程度: 这些解释末必是唯一正确答案, 甚至可能在时间长河里会被证明不正确, 但是他们给我们提供的不 是正确, 而是丰富的观察维度和开阔的视野。\n  這個部分, 也是我們做科學研究寫文章的基本需求. 對同樣的問題, 提供另一個觀察維度, 讓視野開闊, 連結不同的知識背景研究社群.\n  發人深省! 我們追求深度與廣度. 要有深潛的能力, 也要有環遊世界的能力. 反思直到現在30歲的人生, 16-25歲這幾年在台北與台灣大學累積了「深潛」的能力儲備; 25-30歲這幾年在美國與普渡大學養成了「環遊世界」的技術儲備. 做研究寫論文來把現象理解做深, 聽課程寫文章把事件見聞做廣.\n  變化: 商業改變生活, 找機會, 借智慧, 成年人的世界真奇妙  商業改變生活: 新的服務, 基於新的科技, 正在改造我們身處的社會, 城市; 影響著我們的工作, 社交, 娛樂. 當代人類社會中, 生活需求由多少的產業來滿足呢? 一日之所需, 百工斯為備; 上升到治理城市國家的層級, 便開始能關心天下事.\n  找機會, 借智慧: 了解不同的商業模型, 來得到自己的「aha! moment」, 於現在的自己是如醍醐灌頂般的享受, 於未來的自己是洞察新時代優雅生活的知識儲備.\n  成年人的世界真奇妙: 人類的群體智慧, 互動產生許多「元宇宙」型態的精神活動. 很多神奇功能的背後, 都有很有趣的原理與巧思, 讓我們可以發現新的做法, 原來還能這麼做! 窺探內裡的秩序與邏輯, 發現屬於自己的真相.\n  後記  到此紀錄了由蔡鈺老師的商業參考得到課程:发刊词: 理解商业, 与世界保持同步 所引發的思考與自我認識. 從智慧是深思熟慮或是見多識廣開始, 體會了每一種解釋不一定是正確的答案, 但會提供豐富觀察維度, 與視野的開闊程度. 商業改變生活, 從商業變化中洞察商業機會, 學習商業智慧, 享受成年人版本的大自然真奇妙.\n  十分過癮!今天是每日一篇文章的第八天. 有了每天寫文章的習慣後, 看到的資訊都會先前處理, 在寫作的過程中仔細處理, 後來交付成一篇基本的文章. 寫成的文章, 就可以讓未來的自己檢視, 也能有效地將資訊個人化, 培養更深刻的見聞. 持續向上, 共勉之！\n  2022.01.06. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-06","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur008%E8%AE%80%E8%94%A1%E9%88%BA%E5%95%86%E6%A5%AD%E5%8F%83%E8%80%83%E7%99%BC%E5%88%8A%E8%A9%9E-%E7%90%86%E8%A7%A3%E5%95%86%E6%A5%AD-%E8%88%87%E4%B8%96%E7%95%8C%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5/","series":["每日文章"],"tags":["商業參考"],"title":"MUR008 讀蔡鈺商業參考發刊詞-理解商業, 與世界保持同步"},{"categories":["寫作"],"content":"清單體的四個角度  紫式晦澀每日一篇文章第7天\n  前言   今天是2022年第5天, 第1週的第1個週三. 今天來整理之前對「清單體」話題的一些筆記.\n  今天的素材主要是從得到APP與網路上收集而來. 從五個訊息源頭做了15個點的筆記. 以下整理為關於清單體的五個角度.\n  結構寫作:快速起承轉合, 體裁骨架, 題材血肉, 提高閱讀便利性 結構化寫作文體:   要想學會快速寫文章，需要掌握一些「易於複製、條理清晰的結構化寫作文體」。 比如日記體、清單體、語錄體、點評體、問答體等。 這些文體最大的優點是幫助寫作者快速搞定文章結構，快速起承轉合，把思想的「血肉」迅速填充到文章的「骨架」當中。  體裁骨架, 題材血肉:   寫文章，首先需要搞定「體裁（文體）」和「題材」的區別。 體裁是文章的種類和樣式，側重形式特徵；題材是文章涉及的領域、話題或素材，側重內容特徵。 文章的體裁，也稱文體，用於解決「用什麼文章形式」「怎麼寫」的問題；題材用於解決「關注什麼話題」「寫什麼」的問題。 掌握結構化的快捷文體，能夠幫我們快速整理思路、鋪陳素材、流暢表達，寫作效率可以明顯提高，也更容易養成持續寫作的習慣。  前結構化寫作:   常見的結構化寫作文體：日記體、清單體、語錄體、資訊體、點評體、圖片體、問答體、倒金字塔體等等。 前結構化寫作最大的功用，是可以幫助寫作者快速解決「文章如何鋪陳」「先寫什麼後寫什麼」「怎麼快速下筆」的問題，鼓勵作者先把文章寫出來，而不必過多糾結於文章怎麼起承轉合。 此外，結構化寫作還有這些優勢：降低理解成本、提高閱讀便利性、易於分享和傳播。  知識分享: 個人喜好排序, 品味清單體, 高級整理者 清單依喜好排序萬事萬物:   一切有邏輯關係的事物都可以用列表的方式來呈現。 我們列清單，是因為萬事萬物開始圍繞著我們的需求喜好來重新排序，而不再受傳統的層級類型的限制。 清單可以做什麼？既可以是個人邏輯梳理的工具，也可以作為結構化社會知識的載體。  清單體（listicle）高度可分享:   內容的清單化：無清單，不傳播 內容的清單化早在產品的清單化之前就已經開始了。 《紐約時報》內部去年5月發佈一份《數字時代革新報告》，其中將BuzzFeed的成名原因總結為3點：積極進取的社交網絡推廣、高度可分享的內容、試驗性的新聞模式。 清單體（listicle）與小測試、短視頻一起，正好構成其高度可分享的、試驗性等3大特色  先做一個高級的整理者:   清單體沒有作者，而只有編輯。或者說，作者的角色降級為「整理者」，很多微信公眾賬號的運營者扮演的正是這樣的角色。 早在2013年，鈦媒體作者魏武揮老師就指出：一個平台活躍度的核心，生產者並不是第一位重要的，整理者才是第一位重要的。 先是高級的整理者，才有辦法同中有異，創新。  知識輸出: 快速輸出精華, 一段三行強操作性, 以編輯鍛鍊邏輯 清單體快速輸出:   在這個注意力短缺，新知識層出不窮的互聯網時代，清單體寫作具有條理清晰、簡單易看、乾貨十足的特點，可以極大地減少讀者的閱讀壓力。 運用清單體寫作，可以快速吸收一本書的精華內容並且快速輸出，即使是面對一本不太對胃口的書，也能運用清單體寫作榨出它極少的好處。 掌握清單體的寫法，對我們好處極大，下面闡述一下清單體寫作的一些技巧。  一段三行強操作性:   文字簡潔，分行羅列清單體講究把複雜的道理簡單說，能用兩個字表達的意思，就不要用5個字。 所以清單體寫作，每句話不要太長，寫完後要多讀幾遍，反復修改，調整或刪除累贅的話。還有要善用空行，把文字分段。 讀者對冗長的文字很容易失卻耐心，把每段話限制在三行以內。標準的清單體格式是，用500~800字，輸出10條清單。  編輯鍛鍊邏輯:   注重邏輯，講究實用。清單體起到提醒知識點作用，一定要清晰明瞭，操作性強。 每條清單體不是簡單的羅列，各條清單體間都有其內在的聯繫。或是層層遞進、或是不同視角、或是按照現象原因方法劃分等。 選好要闡述的清單後，要思考，把他們按照什麼樣的方式去闡述，更容易讓人記住?可以運用思維導圖，對清單進行梳理，從而更有條理地闡述。 還有寫清單體的閱讀對象除了自己，還有別人。要考慮別人能不能看懂，對他們有沒有幫助？自己日後復習又能不能看懂？  每日文章: 以清單體草稿寫作, 以文章解答讀者問題 作為寫作草稿的清單體:   我們可以在自己擅長的領域多花時間做積累，積累能夠寫清單的話題，有時間就蒐集整理素材，存入素材庫。 等到需要寫的時候，就把這些清單拿出來，也就不愁斷更了。 清單體比較適合分享知識類內容的文章，先確定大概的主題，然後廣泛搜索類似的網絡素材，並做好排序，就可以完成一篇清單體文章。 清單體相對好寫，關鍵是清單蒐集的質量要高。清單體一般最少湊足10條，但如果內容太多，就要捨得刪減，留下最精彩的。 最好的方式是找到專屬寫作主題，透過寫作主題反覆練習，戰勝自己的懶惰。  為讀者提供解答:   讀者愛看清單體，重點在於能一次看到多項介紹、比較，省去他花時間爬文，而且數量多，容易激起人性中，害怕錯過的特性，通常會有不錯的點閱。 寫出專屬你的清單體 清單體因為是以資料整理為主，導致相同主題能寫的資料有限，而在你之前，可能已經有很多人寫過，要和其他筆者做出差異，建議做足競爭者分析的功夫。 瞭解對方哪塊的資訊不足，而你能補充哪些資訊，替讀者解決問題。 重點就是瞭解讀者需要哪些資訊，幫助他們解決問題。  後記  到此我們提煉了與清單體相關的四個角度: 結構寫作, 知識分享, 知識輸出, 每日文章. 道與術皆有, 寫文章就能刺激自己具體化累積的知識, 留下數位足跡. 累積夠多的輸出後, 會產生湧現現象, 發展出更新的角度與觀點, 醍醐灌頂, 找到更好的知識模型.\n  自我反思, 今天已經是每日一篇文章的第七天. 的確, 現在看到各種資訊都會有意識地先整理成清單體, 累積夠多的知識點以後, 再以文章的形式輸出. 在輸出的過程, 提煉自己的邏輯組織, 總結小標題的能力. 這類的能力稱為「編輯能力」, 而世界上那麼多存在的知識, 要靠自己精選組織各種資訊, 成為文本, 才可以讓未來的自己回顧, 往更深層的理解前進. 持續向上, 共勉之！\n  2022.01.05. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-05","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur007%E6%B8%85%E5%96%AE%E9%AB%94/","series":["每日文章"],"tags":[],"title":"MUR007 清單體的四個角度"},{"categories":["可信任的AI"],"content":"差分隱私尋根  紫式晦澀每日一篇文章第6天\n  前言   今天是2022年第4天, 第一週的第一個週二. 今天來思考差分隱私最基礎的定義.\n  今天的素材是Cynthia Dwork與Aaron Roth的The Algorithmic Foundations of Differential Privacy 的第二章所節選的材料.\n  差分隱私故事: 背景, 期望, 隱私洩露  差分隱私背景: 保護隱私的數據分析問題由來已久，橫跨多個學科。隨著關於個人的電子數據變得越來越詳細，以及技術使這些數據的收集和整理變得越來越強大，對一個強大的、有意義的、數學上嚴格的隱私定義的需求也在增加，同時也需要一個滿足這個定義的計算豐富的算法(a robust, meaningful, and mathematically rigorous definition of privacy, together with a computationally rich class of algorithms)類別。差分隱私就是滿足這樣定義的一系列演算法。\n  對隱私保護的期望: ”差分隱私 \u0026ldquo;描述了數據持有者對數據主體做出的承諾。\u0026ldquo;如果允許你的數據被用於任何研究或分析，無論其他研究、數據集或信息來源如何，你都不會受到不利或其他的影響。\u0026rdquo; 在最好的情況下，不同的私有數據庫機制可以使機密數據廣泛用於準確的數據分析，而不需要依賴於數據清洗、數據使用協議、數據保護計劃或限制訪問。\n  回答太清楚, 隱私就洩漏: 儘管如此，數據的效用最終還是會被消耗掉：信息恢復的基本法則(Fundamental Law of Information Recovery )指出，對太多問題的過度準確的回答會以驚人的方式破壞隱私。差別隱私的算法研究的目標是盡可能推遲這種不可避免性。\n  差分隱私是一個定義，不是一種算法: 對於一個給定的計算任務$T$和一個給定的$\\varepsilon$值，將有許多差分隱私算法以$\\varepsilon$-差分隱私的方式實現$T$。有些算法會比其他算法有更好的準確性。當$\\varepsilon$較小時，為$T$找到一個高度精確的$\\varepsilon$-差分隱私算法可能是困難的，就像為一個特定的計算任務找到一個數值穩定的算法一樣困難。\n  形式化基礎元素-輸出值機率向量, 隨機演算法, 其差分隱私性質. 機率單純型: 裡面的每個$x$都代表著一個「機率向量」, 對應每個可能輸出值的機率.   Definition 2.1 (Probability Simplex). Given a discrete set $B$, the probability simplex over $B$, denoted $\\Delta(B)$ is defined to be: $$\\Delta(B)={x \\in \\mathbb{R}^{|B|}: x_{i} \\geq 0 \\text { for all } i \\text { and } \\sum_{i=1}^{|B|} x_{i}=1}$$\n 隨機演算法: 看作一個隨機映射, 對一個固定的輸入a, 有一定的概率輸出b. 這個機率向量被前面的機率單純型給描述.一般來說，一個具有域$A$和（離散）範圍$B$的隨機算法將與一個從$A$到$B$上的概率單線的映射有關，表示為$\\Delta(B)$ 。   Definition 2.2 (Randomized Algorithm). A randomized algorithm $\\mathcal{M}$ with domain $A$ and discrete range $B$ is associated with a mapping $M: A \\rightarrow \\Delta(B) .$ On input $a \\in A$, the algorithm $\\mathcal{M}$ outputs $\\mathcal{M}(a)=b$ with probability $(M(a))_{b}$ for each $b \\in B$. The probability space is over the coin flips of the algorithm $\\mathcal{M}$.\n 數據庫的長度: 我們將認為「數據庫$x$」是來自宇宙$\\mathcal{X}$的記錄集合。用直方圖來表示數據庫往往很方便：$x\\in\\mathbb{N}^{|\\mathcal{X}|}$，其中每個條目$x_{i}$代表數據庫$x$中$i\\in\\mathcal{X}$類型的元素數量。在這種表述中，兩個數據庫$x$和$y$之間距離的自然度量將是它們的$\\ell_{1}$距離。   $|x|{1}$是衡量數據庫$x$的大小（即它所包含的記錄數. $|x-y|{1}$是衡量$x$和$y$之間有多少記錄不同。\n 隨機算法的差分隱私性質: 我們現在準備正式定義差異化隱私。直觀上, 保證了隨機化算法, 在類似的輸入數據庫上, 輸出是相似的。   Definition 2.4 (Differential Privacy). A randomized algorithm $\\mathcal{M}$ with domain $\\mathbb{N}^{|\\mathcal{X}|}$ is $(\\varepsilon, \\delta)$-differentially private if for all $\\mathcal{S} \\subseteq \\operatorname{Range}(\\mathcal{M})$ and for all $x, y \\in \\mathbb{N}^{|\\mathcal{X}|}$ such that $|x-y|_{1} \\leq 1$ : $$ \\operatorname{Pr}[\\mathcal{M}(x) \\in \\mathcal{S}] \\leq \\exp (\\varepsilon) \\operatorname{Pr}[\\mathcal{M}(y) \\in \\mathcal{S}]+\\delta $$where the probability space is over the coin flips of the mechanism $\\mathcal{M}$. If $\\delta=0$, we say that $\\mathcal{M}$ is $\\varepsilon$-differentially private.\n  保護隱私失敗的機率$\\delta$:通常情況下，我們對$\\delta$的值感興趣，它小於數據庫規模的任何多項式的倒數。特別是，$\\delta$的值在$1 /|x|_{1}$的數量級上是非常危險的：它們允許通過公佈少數數據庫參與者的完整記錄來 \u0026ldquo;保護隱私\u0026rdquo;.\n  有沒有失敗機率, 解釋起來很不同:然而，即使$\\delta$可以忽略不計，在$(\\varepsilon, 0)$和$(\\varepsilon, \\delta)$差異性隱私之間也有理論上的區別。其中最主要的是相當於量化順序的轉換。前者的輸出會差不多, 但後者的輸出可以差很多\n   $(\\varepsilon, 0)$差分隱私確保，對於機制$\\mathcal{M}(x)$的每一次運行，觀察到的輸出（幾乎）同樣可能在每個相鄰的數據庫中同時被觀察到。 相反，$(\\varepsilon, \\delta)$差分隱私說，對於每一對相鄰的數據庫$x, y$，事後觀察到的值$\\mathcal{M}(x)$在數據庫為$x$時比在數據庫為$y$時產生的可能性要大得多或小得多，這是極其不可能的。 然而，給定一個輸出$x_i\\sim\\mathcal{M}(x)$，有可能找到一個數據庫$y$，使$x_i$在$y$上產生的可能性遠遠大於數據庫為$x$時的可能性。也就是說，$x_i$ 在$\\mathcal{M}(y)$分布中的質量可能大大高於它在$\\mathcal{M}(x)$分布中的質量。   這樣來說，$(\\varepsilon, \\delta)$差分隱私雖然保護隱私, 但也讓之後相關的機器學習任務很難做.\n 隱私損失: 控制隱私預算, 免疫後處理轉換 定義隱私損失: 關鍵量是 $$\\mathcal{L}_{\\mathcal{M}(x) | \\mathcal{M}(y)}^{(\\xi)}=\\ln \\left(\\frac{\\operatorname{Pr}[\\mathcal{M}(x)=\\xi]}{\\operatorname{Pr}[\\mathcal{M}(y)=\\xi]}\\right).$$ 我們把它稱為觀察$\\xi$所產生的隱私損失。   這種損失可能是正的（當一個事件在$x$下比在$y$下更可能發生），也可能是負的（當一個事件在$y$下比在$x$下更可能發生）。 正如我們在Lemma 3.17中看到的，$(\\varepsilon, \\delta)$差分隱私確保對於所有相鄰的$x, y$，隱私損失的絕對值將被$\\varepsilon$所約束，概率至少為$1-\\delta$。   這個定義是把$e^{\\epsilon}$的部分做了個轉換; 可否把這個想成policy的decision變化的程度? 但感覺與隱私沒什麼關係. 這個寫法的好處可以跟似然比接起來, 也難怪可以用假設檢定的框架來做.\n  差分隱私對後處理是免疫的: 數據分析員在沒有關於私人數據庫的額外知識的情況下，不能計算私人算法$\\mathcal{M}$的輸出的函數並使其減少差異性隱私。\n   也就是說，如果一個算法保護了個人的隱私，那麼數據分析員不能增加隱私損失, 無論是在正式定義下還是在任何直觀意義上。 從形式上看，與數據無關的「後處理映射$f$」與$(\\varepsilon, \\delta)-$差分隱私算法$\\mathcal{M}$的組合也是$(\\varepsilon, \\delta)$差分隱私。   也是這個特點, 讓隱私處理後的資料可以被公開做研究.\n 後記  到此我們看過了Cynthia Dwork與Aaron Roth的The Algorithmic Foundations of Differential Privacy 的第二章的節選內容. 在「說太清楚就隱私洩露」的事實下, 我們需要給隨機演算法增加「差分隱私」的性質, 以免惡意人士透過觀察隨機演算法的輸出值, 來還原特定的數據. 形式化框架下, 經過差分隱私處理後的數據, 在後處理下不會造成額外的隱私洩露. 對形式化的學術研究而言, 「隱私損失」會是重點分析目標.\n  至此, 對差分隱私又多瞭解了一點, 也可以理解其形式化細節會與似然比, 假設檢定等等技術有關係. 很多統計的結果都可以套上這層外衣. 之後可以多想想這些基礎的關聯.\n  2022.01.04. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-04","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur006%E5%B7%AE%E5%88%86%E9%9A%B1%E7%A7%81%E5%B0%8B%E6%A0%B9/","series":["每日文章"],"tags":["差分隱私"],"title":"MUR006 差分隱私尋根"},{"categories":["合成數據","可信任的AI"],"content":"合成數據如何幫助基於機器學習的偵測詐欺?  紫式晦澀每日一篇文章第5天\n  前言   今天是2022年第3天, 第一週的第一個週一!今天來思考「合成數據(Synthetic Data)」是如何在金融科技領域中，幫助「詐欺偵測(Fraud Detection)」的任務.\n  今天的素材主要是從文章Follow the Trail: Machine Learning for Fraud Detection in Fintech Applications 節選提到合成數據的相關段落 .\n  合成數據用於詐欺偵測-檢測率, 訓練數據集來源  合成數據對詐欺偵測的效果: 本文章實驗了ML方法對欺詐檢測的貢獻, 分別利用真實數據集與「合成數據集」來訓練. 此文章討論了各種方法在「檢測率」的有效性. 此外, 分析了所選特徵對其性能的影響.\n  詐欺偵測的訓練數據集-Kaggle, ML Repository, Simulator:\n   A. 金融科技的詐欺檢測, 缺乏公開可用的測試數據. B. 來源一: Kaggle數據集 (括信用卡數據集[9]、銀行交易數據[10]和區塊鏈歷史數據[11]). C. 來源二: 已知的、稍舊的合成數據集可以在UC Irvine ML Repository中找到（例如，UC Irvine[12]） D. 來源三:模擬器(Simulator) BankSim[13]和PaySim[14]等模擬器被應用於解決這個問題。前者代表了一個基於代理的銀行支付模擬器，而後者則通過生成客戶和執行交易來模擬移動交易。  合成數據集範例 PaySim: 基於私人數據, 注入惡意行為, 產生合成數據 PaySim的模擬器:   A. 在4.2.2節中，將介紹一個使用名為PaySim的模擬器生成的合成數據集（PaySim數據集在下文中）。 B. PaySim使用私人數據集的匯總數據，生成一個類似於交易正常運行的合成數據集，並注入惡意行為，以便日後評估欺詐檢測方法的性能。 C. 這是通過在一個非洲國家的真實交易樣本基礎上模擬移動支付交易來實現的。原始數據是由一家跨國移動金融服務提供商提供的[104]。 D. 在這個特定的數據集中，代理商的欺詐行為旨在通過控制或客戶的賬戶來獲利，並試圖通過轉移到另一個賬戶來清空資金，然後從系統中套現。 E. 數據集詳情見表5。 Table 5. Synthetic Financial Datasets for Fraud Detection dataset overview.    Dataset name Synthetic Financial Datasets for Fraud Detection     Domain Financial Transactions   Url https://www.kaggle.com/ntnu-testimon/paysim1    Year (accessed on 30 November 2020)   Type 2015   Subset Synthetic data   Annotated PS_20174392719_1491204439457_log.csv   Unbalanced Yes   No. of entries Yes   Contamination rate 6,362,620   Time duration 0.129%   No. of features 1 month   List of features 11    step, type, amount, name0rig, oldbalance0rg,      定義PaySim: PaySim.   A. 一個移動貨幣支付模擬器 移動貨幣支付模擬案例研究是基於一個真實的公司，該公司開發了一個移動貨幣實施方案，為手機用戶提供了使用手機作為一種電子錢包在他們之間轉移資金的能力。 B.「任務」是開發一種能夠檢測出表明欺詐的可疑活動的方法。 C. 不幸的是，在我們研究的最初階段，這項服務只在演示模式下運行。這使我們無法收集任何可用於分析可能的檢測方法的數據。 D. PaySim的開發包括兩個階段。  D.a 在第一階段，我們模擬並實現了一個MABS，它使用了真實的移動支付服務的模式，並根據對真實系統開始運行時可能出現的情況的預測，生成了合成數據。 D.b在第二階段，我們獲得了該系統的財務交易日誌，並開發了一個新版本的模擬器，該模擬器使用匯總的交易數據來生成更類似於原始來源的財務信息。   E. Keywords [en]: multi-agent based simulation, fraud detection, retail fraud, synthetic data http://bth.diva-portal.org/smash/get/diva2:1085629/FULLTEXT03.pdf .  BankSim: 用於詐欺檢測研究的合成數據 BankSim:   A. 小節4.2.3 介紹的數據集是使用BankSim創建的，這是一個基於代理的銀行支付模擬器，基於西班牙一家銀行提供的匯總交易數據樣本。 B. 目標: 生成可用於欺詐檢測研究的合成數據。 C. 這個數據集結合了正常的支付和已知的欺詐特徵，不包含任何個人信息或任何其他交易的披露。 D. 數據集的詳情見表6。    Dataset name Synthetic data from a financial payment system     Domain Financial Transactions   Url https://www.kaggle.com/ntnu-testimon/banksim1    Year (accessed on 30 November 2020)   Type 2014   Subset Synthetic data   Annotated bs140513_032310.csv   Unbalanced Yes   No. of entries Yes   Contamination rate 594,643   Time duration 1.21%   No. of features 6 months   List of features 10   Subset step, customer, age, gender, zipcode0ri,   Annotated merchant, zipMerchant, category, amount, fraud   Unbalanced bsNET140513_032310.csv   No. of entries Yes   Contamination rate Yes   Time duration 594,643   No. of features 1.21%   List of features 6 months      Bank Transaction Data: 檢測欺詐交易和洗錢的合成數據 Bank Transaction Data:   A.Bank Transaction Data是一種分析工具，旨在檢測欺詐交易和洗錢。 B. 開發人員希望建立一個工具，可以使用IFSC代碼提取銀行名稱；通過系統獲取兩個不同賬戶在同一日期的借方和貸方的相同數量的交易以及匹配的敘述；並在敘述的基礎上對類似交易進行分類。 C. 數據集的細節見表7。    Dataset name Bank Transaction Data     Domain Financial Transactions   Url https://www.kaggle.com/apoorvwatsky/bank-    Year transaction-data (accessed on 30 November 2020)   Type 2017   Subset Synthetic data   Annotated bank.xlsx   Unbalanced No   No. of entries n//a   Contamination rate 116,201   Time duration n//a   No. of features 7 months    8   List of features Account No., Date, Transaction Details, Cheque    No. , Value Date, Withdrawal Amount, Deposit      結果與洞察: 合成數據集中, 特徵的可變性不夠高  Variability of features in a synthetically created dataset might not be on a high enough level.\n 合成數據集中, 特徵的可變性不夠高:   圖15中給出了被測試的集合方法的ROC曲線比較。 基於tpr和tnr的比較分析表明，對於一個給定的數據集，AdaBoost在測試方法中表現最好。 同時，可以注意到這三種測試方法的靈敏度和特異性都很高，幾乎為1，這表明合成的數據集中特徵的可變性可能還不夠高(variability of features in a synthetically created dataset might not be on a high enough level)。 還應該注意的是，在這個特定的數據集上，集合方法的表現優於離群點檢測方法。   結論與洞察: 利用集群方法, 執行基於合成數據的訓練, 會有更好的效果.  ensemble approaches significantly outperformed outlier detection methods on the two tested synthetic datasets\n 集成方法在合成數據集上表現較好   所進行的實驗結果證實了ML的好處。 首先，現有的ML算法成功地在複雜的數據集中檢測到了異常情況。 此外，實驗結果證實，ML方法可以通過支持增強欺詐檢測能力的方式，成功地為金融技術系統的安全做出貢獻。 此外，研究還發現，特徵工程和選擇會嚴重影響某些算法的性能，仔細選擇特徵可以提高整體性能並限制某些特徵的負面影響。 還應注意的是，集合方法對可變的特徵選擇情況保持了更穩健的性能，總體表現非常好，在大多數情況下比離群值檢測方法更好 集合方法在兩個測試的合成數據集（PaySim和BankSim）上的表現明顯優於離群值檢測方法 (ensemble approaches significantly outperformed outlier detection methods on the two tested synthetic datasets) 而在包含真實數據的測試數據集（CreditCard）上，這兩種方法的結果是相當的。  後記  到此我們看過了Follow the Trail: Machine Learning for Fraud Detection in Fintech Applications 文章中關於「合成數據」的段落與洞察。本文章指出(1) 公開用於訓練機器學習模型的合成數據集(PaySim 與 BankSim), 特徵的可變性可能不夠高, (2) 利用集群方法(Ensemble Method), 執行基於合成數據的訓練, 會有更好的效果.\n  這邊所謂的「合成數據」的邏輯, 似乎是加入惡意行為, 然後看使用的算法是否能夠成功抓到惡意行為. 惡意行為的「產生機制」可否用deep learning來做呢? 這樣的generative model, 生成帶有隱藏惡意行為的驗證資料(Validation dataset), 以此來審計(audit)系統中使用的機器學習算法. 這類似學校對TA做種族平等的培訓, 以避免TA在課堂上做出違反符合美國大學系統價值下認為的平等.\n  十分有趣, 之後需要多學習一些詐欺偵測的資料科學工程技術, 來進一步思考此文章給出對合成數據集的洞察. 持續精進, 共勉之！\n  2022.01.03. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-03","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur005%E5%90%88%E6%88%90%E6%95%B8%E6%93%9A%E5%A6%82%E4%BD%95%E9%97%9C%E8%81%AF%E5%81%B5%E6%B8%AC%E8%A9%90%E6%AC%BA/","series":["每日文章"],"tags":["金融科技","詐欺偵測"],"title":"MUR005 合成數據如何幫助基於機器學習的偵測詐欺?"},{"categories":["寫作"],"content":"知識管理的五個角度  紫式晦澀每日一篇文章第4天\n  前言   今天是2022年第2天! 今天來整理之前對「知識管理」話題的一些筆記.\n  今天的素材主要是從得到APP上收集而來. 從五個訊息源頭做了15個點的筆記. 以下整理為關於知識管理的五個角度.\n  組織知識管理: 重要性, 難題與巧勁  組織知識管理的重要性: 管理學家彼得·德魯克反復強調，知識型組織中，知識是最重要的資源。「知識管理」關係著組織能不能持續、高質量地發展。\n  組織知識管理的難題:組織的智慧分散在不同部門、員工身上。想找文件只能做伸手要，想要學習過去的經驗只能當面問，沒有一個統一的入口能讓人高效地找到有用的知識.\n  組織知識管理的巧勁: 人和知識能不能有效匹配，要看知識是不是正好對應你要解決的問題，是不是足夠及時；還要看量，「少瞭解決不了問題，多了增加識別難度。」\n  個人知識管理：數據，資訊，底層規律  數據管理: 第一個是數據管理的維度。在這個維度上，我們所談論的知識管理更多是具體的「數據層面技巧」。比如，下載的文件怎麼保存？學到的知識點怎麼歸類？如何快速搜索文件？如何給文件貼標籤？怎樣整理文件夾？在哪裡找到合適的書單？等等。\n  這個部分年輕時我也犯過很多錯, 想要收集很大量的數據, 包括書本, 課程, 雜誌等等. 但現在一切都變得很方便以後, 反而是應該讓數據就留在他的出處, 而我們僅需要根據當下的需求去取回相對應的部分, 組織成能解決問題的知識即可.\n  資訊管理: 第二個是信息管理的維度。在這個維度上，我們關注的是怎樣更好地理解、消化和應用獲得的各個知識點。有很多非常有用的方法可以組織起來強化這一過程，比如：如何做讀書筆記？如何用思維導圖增強理解？學習中精讀和泛讀的區別、行動學習法、刻意練習等等。而能夠有效利用這些方法，也是一個學習者進階的標誌——能夠有效地把學到的知識用於解決問題。\n  這個部分有了Obsidian以後, 逐漸從note-taking轉化為note-making. 的確, 要將「數據, 文本」轉化成「資訊, 知識」需要倚靠各種框架來蒸餾出價值. 我們在學習的過程需要借助「語言的重複性」來增進理解, 但記憶的過程需要「知識的結構化」材能有效建立資訊之間的連結. 這個部分小小Sha的知識卡片書籍幫助很大, 持續master裡面的技藝.\n  底層邏輯管理: 第三個是底層規律的維度。在這個維度上，我們關心的不僅僅是具體的方法和技巧，更關心自己的認知深度：我們必須在大量具體知識積澱的基礎上，形成更宏觀和抽象的理解，在深層次上掌握普遍規律，從而將之前學到的繁雜的知識用一根線串起來，在具體知識之外找到新的答案，將有形化為無形，又將無形用於有形。\n  這個部分是30歲要更加要求自己的. 建立自己的知識體系已經簡單, 但如何「刻意驗證」來不斷升級自己知識體系的能力, 就要靠持續做各種不同的應用來累積與這個事件具體的經驗。做項目可以幫助我們累積這方面的能力！終身學習, 持續精進, 做時間的朋友！\n  知識管理三學派: 技術, 行為, 綜合  技術學派-知識本身: 技術學派認為知識管理就是對信息的管理，強調運用信息技術手段管理顯性知識。他們強調運用電子郵件、群件及其他工具從人、知識庫以及計算機網絡獲取「顯性知識」。許多學者，包括計算機專業人員，目前仍然在深化這方面的研究，諸如數據挖掘技術、人工智能技術、知識存儲與更新技術等。在知識管理未來的發展中，信息技術將會提供更多、更強有力的支持。在知識管理的實踐中人們已逐步達成如下共識：信息技術雖然重要，但只是知識管理成功實施的必要而非充分條件。\n  行為學派-知識擁有人: 該學派認為知識管理是對擁有知識的人（即知識工作者）的管理，他們重視對表現為人力資本和結構資本的「智力（知識）資本」的管理。比較關注知識管理與企業戰略、企業競爭優勢關係的研究，還關注組織間知識管理的研究。\n  綜合學派-人與知識並重: 該學派認為知識管理不僅要對信息和人進行管理，還要將信息和人連接起來進行管理；知識管理就是要將信息處理能力和人的創新能力相互結合，增強組織對環境的適應能力。該學派融合了信息技術及經濟學、管理學的相關知識，推動了技術學派和行為學派的相互交流、學習與融合。由於綜合學派能用較為系統、全面的觀點看待和實施知識管理，所以能很快被實踐者所接受。\n  知識管理方法: 產生, 分享, 管理  資訊化風潮: 受到 1990 年代的資訊化（Informatization），知識管理的觀念出現，成為企業或組織累積知識財富、創造更多競爭力的人文與技術具備的系統。如何深化「知識產生」的內涵、針對不同族群去做「知識分享」的設計，是「知識管理」當前與未來更重要的目標。\n  五步驟-產生與分享: 將知識透過「獲得、記錄、組織、存取與更新」，不斷「去由外而內的累積」以及「由內而外的優化」，助於企業及個人做出決策，因應環境的變遷。在這五個步驟的循環中，前面三步驟為「知識的產生」－強調如何使隱性的知識（最後一段會說明）方法化（methodology），後面兩步驟為「知識的分享」－強調讓受眾（員工、網路社群、大眾等等）容易瞭解、容易接受，並且容易感受到「成果」。如何深化「知識產生」的內涵、針對不同族群去做「知識分享」的設計，這兩大部分是「知識管理」當前與未來更重要的目標。\n   獲得\u0026ndash;\u0026gt;紀錄\u0026ndash;\u0026gt;組織\u0026ndash;\u0026gt;存取\u0026ndash;\u0026gt;更新\n 方法（methodology): 一種帶有約束性甚至強制性的模型規範，它會明確地告訴人們應該做什麼，不應該做什麼，什麼先做，什麼後做，怎樣才能事半功倍，取得最大的效益等。因此，方法往往是以規範、章程，條例，使得接受者能有共同的畫面去瞭解這個概念。  知識管理心法: 多元資訊渠道, 秉持心中之軸, 實踐輸出效應 多元資訊渠道: 積累關注不同信息渠道，去試一切錯。增加信息入口，是使人突破成長的最好辦法。常見的信息入口比如，閱讀經典書籍，互聯網信息資源等等，更難獲得的信息入口其實在人群中，也就是人際關係和貴人指路。 ​​​​不用擔心錯過什麼，有一天你會明白，關閉可能性 與 開拓可能性，同樣重要。   關閉可能性 與 開拓可能性，同樣重要。\n  秉持心中之軸: 你的個人憲法就是你一直秉持的信念、價值觀、思維方式，要經過深思熟慮，幾次修改，才能定案。從你最深刻的經歷、最難忘的故事中，回想你最刻骨銘心的事情，那其中包含你的人生哲學。原則是恆久不變的，你對原則的理解是會因為經歷而改變的，所以原則是歷久彌新的，是可以信賴的。\n  實踐輸出效應:去新的方法、思維，首先通過實踐輸出。比如說手帳方法具體體現了生活方式和工作方法，記錄反思在手帳上。第二層輸出是我實踐之後的復盤反思，總結成文章，寫成公眾號文章。我的公眾號是以個人成長、生活方式為核心。公眾號文章是電子生活+工作手帳。第三層輸出是跟進自己的行動、以及觀察生活中其他人的行為，調動我知識體系中的觀點、思維方式，去再一次更新我的認知框架和輸出效應。\n   工作方法\u0026ndash;\u0026gt; 復盤反思\u0026ndash;\u0026gt; 更新認知框架與輸出效應.\n 後記  到此我們看過了知識管理的五個面向; 對於個人或者組織, 都是需要想「數據, 資訊, 底層規律」三者是如何結合進工作流. 好的工具, 好的團隊, 促進知識的產生, 管理與分享. 長期而言, 知識是在實踐的過程中, 將自己的知識體系與外部的世界做主動驗證, 藉由試錯來高速迭代.\n  自我反思, 現在已經能藉由主動輸出, 來進行高強度的知識應用. 讓平時的瀏覽成為積累素材, 讓平時的休憩成為編輯文章的好時機. 材料累積久, 產生湧現效應, 便能有意想不到的體悟. 另外, 獲得\u0026ndash;\u0026gt;紀錄\u0026ndash;\u0026gt;組織\u0026ndash;\u0026gt;存取\u0026ndash;\u0026gt;更新這個知識管理的五步驟, 也不謀而合與每日文章輸出相同. 持之以恆, 共勉之！\n  2022.01.02. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-02","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur004%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E4%BA%94%E5%80%8B%E8%A7%92%E5%BA%A6/","series":["每日文章"],"tags":[],"title":"MUR004 知識管理的五個角度"},{"categories":["可信任的AI"],"content":"拉普拉斯差分隱私機制的四個面向  紫式晦澀每日一篇文章第3天\n  前言   今天是2022年的第一天! 今天思考了許多關於差分隱私相關的問題. 今天針對最經典的差分隱私機制,「拉普拉斯差分隱私機制」, 來做文章思考.\n  今天的素材是Cynthia Dwork與Aaron Roth的The Algorithmic Foundations of Differential Privacy 的章節3.3, 以及維基百科關於Additive noise mechanism 的條目.\n  場景: 數據庫查詢  數據庫查詢: 問題起源於「數據庫查詢(Database queries)」: 當我們查詢數據庫, 獲得數值資料時, 算法會將數據庫映射為k個實數回傳. 這個映射寫作$$f:\\text{數據庫}\\mapsto \\text{k個實數}.$$\n  敏感性: 我們能多準確地完成這樣的查詢呢? 利用「敏感性」來妙術最壞情況下, 一個人的數據可以改變「查詢映射f」的程度。   不確定性之必要: 萬一上述的敏感性很劇烈, 那麼惡意攻擊者就可以透過比較查詢結果, 來回推特定用戶的特定數據. 為了避免特定用戶的特定數據被還原出來, 增加不確定性是必要的.\n  直觀: 一個「查詢映射f」的靈敏度, 給出了我們必須對其輸出進行多大的擾動, 才能保護隱私, 的上限。 (The sensitivity of a function gives an upper bound on how much we must perturb its output to preserve privacy. )\n  方案: 增加拉普拉斯分佈為不確定性  拉普拉斯分佈: 拉普拉斯分布是指數分布的一個對稱版本。   拉普拉斯機制: 拉普拉斯機制將簡單地計算「查詢映射f」，並用來自拉普拉斯分布的噪聲來擾動每個坐標。 微調噪聲的規模將被校准為「查詢映射f的敏感性」（除以ε）。   拉普拉斯機制的隱私性質: 拉普拉斯機制保留了(ε,0)微分隱私。 處理前與處理後, 兩個查詢結果出現的機率, 不會差太多.\n  實例: 具體數據庫查詢任務  與機器學習的關係？\n  計算查詢: (Counting queries) 在數據庫中，有多少元素滿足特定\n  直方圖查詢: (Histogram queries) 將資料可能分佈的空間分割為單元格，查詢每個單元格中有多少數據庫元素\n  姓氏查詢: 從10,000個潛在名字的列表中計算出哪些名字在2010年人口普查的參與者中最常見. 是一種直方圖查詢.\n  差分隱私選取: (Differential private selection) 結果的空間是離散的，任務是產生一個 \u0026ldquo;最佳 \u0026ldquo;答案，在這種情況下，就是人口最多的直方圖單元。\n  最常見的病症: 在一組受訪者的醫療史中，哪種病症（大約）是最常見的，所以這組問題是，對於所考慮的每種病症，個人是否曾經接受過這種病症的診斷。\n  推廣: 加性噪音機制  推廣定義: 從預先確定的分布中, 添加受控的噪聲, 是設定「差分隱私機制」的一種方式。這種技術對於設計敏感數據上的實值函數的隱私機制很有用。常用於添加噪聲的分布包括拉普拉斯和高斯分布。\n  推廣敏感性: 令$\\mathcal{D}$為資料集; $f:\\mathcal{D} \\mapsto \\mathbb{R}$ 為查詢映射。則查詢映射的敏感性$\\Delta f$定義為 $$ \\Delta f = \\max |f(x)-f(y)|. $$ 這裡的最大值是在$\\mathcal{D}$中, 只差一個元素的一對資料集$x$和$y$。對於維度高的查詢映射函數, 通常在$\\ell_{1}$或$\\ell_{2}$下測量敏感性。\n  論證差分隱私性: 要論證該機制滿足$\\epsilon$差分隱私，需證明「輸出分布」在乘法意義上是封閉的。技巧是利用分佈本身的似然比.\n  後記  到此我們走完了一趟拉普拉斯機制相關的的基礎細節. 基本上, 問題的場景是對數據庫的各種查詢. 如果給準確的數值, 那惡意攻擊者有可能透過查詢結果來回推特定個體的某些數值. 因此, 根據查詢的特性本身針對資料變動的「敏感度」, 設計回傳的數值額外加上的不確定性, 就可以防止這類的惡意攻擊. 其中要量化隱私保護的程度, 就會用到拉普拉斯分佈的各種性質; 也不難想像「充分統計量」對應著「查詢映射」, 而「隱私保護查詢結果」對應著「不確定性部分的集中不等式」.\n  十分有趣, 而這類的工作在2021已經被延伸到各種機器學習模型的訓練上, 造成很多機器學習任務表現被影響甚巨. 因此, 藉由做「模型審計」相關的研究, 來評估「基於隱私保護資料所訓練的機器學習模型」, 是一個基礎必須做的工作. 合成數據, 在這個分野上, 是有什麼樣的直覺可以解決這個問題呢?\n  2022.01.01. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2022-01-01","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur003%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%B7%AE%E5%88%86%E9%9A%B1%E7%A7%81%E6%A9%9F%E5%88%B6%E7%9A%84%E5%9B%9B%E5%80%8B%E9%9D%A2%E5%90%91/","series":["每日文章"],"tags":["差分隱私"],"title":"MUR003 拉普拉斯差分隱私機制的四個面向"},{"categories":["日本"],"content":"關於大晦日的五個知識點  紫式晦澀每日一篇文章第2天\n    今天是2021年的最後一天! 今天在Hololive六期生的出道後看了許多的vtuber. 其中日本文化裡一年的最後一天為「大晦日」. 一開始以為是悔改的意思, 但搜集資料後發現故事還不少, 很有意思.\n  今天的素材是在google上面搜尋「大晦日」, 將閱讀文章摘要三點累積而成. 共讀了5個文章, 總結出十五條細節. 下面總結出關於大晦日的五個知識點.\n  年末說法: 大晦日(おおみそか)，指的是每年新曆的12月31日。另外, 表達最後一天的日語還有「年末」和「年の暮れ(としのくれ)」。其中「末(matsu)」和「暮れ(kure)」表示「～的最後」的意思，所以兩者都表示「年末」、「1年的結束」。   神社文化: 神社在大晦日將舉行「大祓い」儀式，以淨化積累了一年的穢物。佛教則為了清除迷惑身心的108個煩惱，將敲響除夜（除夕夜）之鐘。人類有108個煩惱，每敲一次鐘就能消除一個煩惱，所以才敲響108次鐘。   晦日緣由: 在舊曆的晦日代表「每月的最後一天」，而一年的最後一天，也就是一年最後一個月的最後一天稱之為「大晦日」。「晦日」可追溯回中國，《公羊傳》中就有出現過「何以不日？晦日也。」的記載. 其中晦日指的是農曆中每月最後一日，當天幾乎看不到月亮. 晉代杜預對《左傳》的注釋就提到，「晦，月終，陰之盡。」在日本，晦字也有「月隠り（つきごもり）」之意，而「つごもり」正是日文「晦日」的其中一個讀法。 日文「晦日」的另一個讀法「みそか」，就是古文中「30日」的讀法〈如20日的讀音是はつか〉，而由於農曆月終不是29就是30，所以兩者稱呼都是「みそか」。  年神文化: 12月31日是日本人為了在「正月」迎接神靈, 而做各種準備的日子。在「正月」，日本人要迎接一年到頭守護家庭的神靈－「年神様」（年神，歲神），因此正月也是歡迎神靈之日。其中, 會於家門使用神靈休憩的靈木－「松」製作的松飾「門松」，立在家門左右。門松，還擔當著神靈的引路標誌。另外, 在玄關的門上面。還會裝飾「注連繩」，以迎接神靈。在神棚（かみだな：室內供奉神靈的架子），要上供「鏡餅」。   初夢文化: 初夢（はつゆめ）是「新年最初所作的夢」. 一般指在1月1日或1月2日夜晚所作的夢. 傳統日本人認為初夢可以用來占卜新的一年運勢. 特別的, 如果夢到了1.富士山（ふじさん）2.鷹（たか）3.茄子（なす）, 是非常吉利的象徵. ① 這三樣都是德川家康喜歡的東西 ② 富士山是日本第一的山、老鷹是最威猛的鳥類、茄子則是重貴的食物（容易腐壞不易保存 ) ③ 富士山是「無事（ぶじ）」的諧音、老鷹是「高（たかい）」的諧音、茄子是「事事順遂（事をなす）」的諧音.  今天是2021年的最後一天. 回顧過去一年成就許多, 也意識到自己更多的不足. 持續思考, 精進自己, 用輸出指導輸入, 用文章精煉思考. 新的一年, 持續學習語言, 程式, 做更落地的研究, 思考商業, 組織執行項目, 承擔更大的責任, 做一個大寫的人.\n  2021.12.31. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2021-12-31","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur002%E9%97%9C%E6%96%BC%E5%A4%A7%E6%99%A6%E6%97%A5%E7%9A%84%E4%BA%94%E5%80%8B%E7%9F%A5%E8%AD%98%E9%BB%9E/","series":["每日文章"],"tags":[],"title":"MUR002 關於大晦日的五個知識點"},{"categories":["寫作"],"content":"每日寫文章的五個心法  紫式晦澀每日一篇文章第1天\n    新年新希望! 每天寫文章來增強自己的表達能力. 現在使用Obsidian與ipad可以很輕鬆收集素材; 接著使用github page來發表每日的文章.\n  今天素材收集是在google上面搜尋「每日寫文章」以後, 照讀到的文章總結出三個面相. 共讀了5個文章, 總結出十五條細節. 這個流程蠻不錯, 之後可以參考, 做淺淺的研究. (跟仔細讀paper的方法不同)\n  固定習慣: 目前的設定是每天晚上十點, 在床邊的書桌寫作. 在十一點左右將文章Po到網站上. 有想過可以將素材收集到臉書的粉絲專頁, 用mac系統的quick note等等. 晚上整理, 輸出, 成為以後寫書的材料.\n  格式魔法: 在開頭寫「紫式晦澀每日一篇文章第X天」, 蒐集要寫的素材所屬於的領域, 以及維持書寫輸出的自律習慣. 這個點很不錯, 讓努力能夠累積, 也有足夠的素材能夠當作更高級的文件的底料.\n  刻意輸入: 不要完美主義, 先完成30分的作品. 之後根據需求, 再把文件完善, 讓分數提高. 在消費媒體時, 也持續打字寫下想法, 這樣就有底稿, 可以執行模塊輸出. 利用「溝通黃金圈」或者「清單體」等等的寫作架構, 就可以文思泉湧, 讓思想具現化.\n  碎片分享: 文件都是改出來的. 當我們消費各種知識, 寫作能夠提升我們總結的能力. 這個過程稱為「知識生產」，而生產出來的產物則是「知識卡片」等等碎片化的知識(知識=資訊+脈絡+流程). 利用總結技巧, 模板化輸出, 是什麼為什麼怎麼做. 將成果天天分享於社群帳號; 累積夠多素材後還能整理成大的文章, 標準化寫作. 用粉絲專業寫平時靈感. 用專業帳號發個人品牌文章.\n  定性心流: 把寫文章步驟化, 例如: 關鍵字，架構，內文，插圖，制式內容，校正，內容說明，摘要，發文. 共九個步驟. 寫的時候不要回頭檢查文章, 只在校正的步驟做檢查重排; 當真的寫不出來, 就抽離, 做其他事情, 一但有了靈感就再繼續, 不要免強.\n  即將邁入三十歲, 感覺要從知識的消費者轉為生產者! 分享其實也是在為未來的自己做知識服務. 寫下來的東西對自己最有用. 文章的再修改也能讓未來的自己看見知識如何逐漸形成. 共勉之!\n  2021.12.30. 紫蕊 於 西拉法葉, 印第安納, 美國.\n","date":"2021-12-30","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/mur001%E6%AF%8F%E6%97%A5%E5%AF%AB%E6%96%87%E7%AB%A0%E7%9A%84%E4%BA%94%E5%80%8B%E5%BF%83%E6%B3%95/","series":["每日文章"],"tags":[],"title":"MUR001 每日寫文章的五個心法"},{"categories":["寫作"],"content":"","date":"2021-12-28","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/rdd001-%E7%A0%94%E7%A9%B6%E8%A8%AD%E8%A8%88%E7%B3%BB%E5%88%97%E5%B0%8E%E6%96%87/","series":["研究設計"],"tags":[],"title":"RDD001 研究設計系列導文"},{"categories":["寫作"],"content":"211223 思考豆腐塊文章的執行面  目的: 藉由寫豆腐塊文章來強化輸出. 讀者: 放在自己的blog上面. 原則: 一篇文章只講一個觀點. 這個觀點, 快的話應該是要從讀的東西輸出 執行: 理想上, 在製作[[AGM331 知識卡片 (Knowledge Card)]]的同時, 就可以加工成[[豆腐塊作文]], 發到網站上, 整理思想.\n目的: 藉由寫豆腐塊文章來強化輸出. 讀者: 放在自己的blog上面. 原則: 一篇文章只講一個觀點. 這個觀點, 快的話應該是要從讀的東西輸出 執行: 理想上, 在製作[[AGM331 知識卡片 (Knowledge Card)]]的同時, 就可以加工成[[豆腐塊作文]], 發到網站上, 整理思想.\n把部落格當作平常練手的豆腐塊區域 練技術, 要實際寫程式練手 練寫作, 用各種豆腐塊練手\n豆腐塊: 簡述一篇學術文章的每個第一段; 給個Profile 這個Profile應該是各種觀點, 與各種術語.\n 可以練手, 用Fintech 與 Synthetic Data的交集來看.\n  Example : Fintech 與 Synthetic Data的交集.  MDPI   關於「備忘」與「筆記」 我現在意識到, 要有意地去改變寫「備忘」與「筆記」的比例; 「備忘」是讀了一些東西的觀後感, 小總結; 「筆記」則是什麼都不看, 環繞自己某個問題寫. 前者要重視轉化「外在文本」為「自身知識儲備」, 後者要重視轉化「自身知識儲備」為「具體問題的解決過程」. 所以在網站上, 只能放「筆記」 在個人知識庫裡, 主要放「備忘」\n","date":"2021-12-23","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/art478-%E8%B1%86%E8%85%90%E5%A1%8A%E6%96%87%E7%AB%A0%E6%80%9D%E8%80%83/","series":["豆腐塊"],"tags":[],"title":"ART478 思考豆腐塊文章的執行面"},{"categories":[],"content":"這是第一篇文章\n思考一: 實踐寫作套路, 學習寫作工作總結   想要研究寫作的套路，早上看了一些關於文案寫作的書。但他們的性質跟我們平常知識生產的模式不太一樣。 在網路上寫部落格的原因是什麼? 我想是經營個人品牌。因為我自己都還沒有個人網站。 那為什麼要建立個人品牌呢因為在現在這個時代我們找工作的履歷不再只是一張紙, 而是一個網站可以表現我們過去幾年的工作。 這個有點像在寫工作總結，那怎麼寫好工作總結呢？我覺得這就是可以看得到App上面的課程。  流程圖原始碼  1graph LR 2\tT(實踐寫作套路); A(發表網路部落格); R(建立個人品牌); Act(強化工作總結技能) 3\tT--\u0026gt;A--\u0026gt;R--\u0026gt;Act 思考二: 邏輯流 邏輯流治天下\n","date":"2021-12-21","img":"","permalink":"https://laplus3667.github.io/zh-tw/posts/art001-guidance/","series":[],"tags":["邏輯流"],"title":"ART001 文章概覽"},{"categories":null,"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/yuin/goldmark  https://github.com/alecthomas/chroma  https://github.com/muesli/smartcrop  https://github.com/spf13/cobra  https://github.com/spf13/viper   Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub .\n","date":"2019-02-28","img":"","permalink":"https://laplus3667.github.io/zh-tw/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"https://laplus3667.github.io/zh-tw/contact/","series":null,"tags":null,"title":"Contact Us"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"https://laplus3667.github.io/zh-tw/faq/","series":null,"tags":null,"title":"FAQs"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"https://laplus3667.github.io/zh-tw/offline/","series":null,"tags":null,"title":"Offline"}]